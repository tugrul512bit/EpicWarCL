<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Cekirdekler</name>
    </assembly>
    <members>
        <member name="T:Cekirdekler.ClBuiltInHelper.ClBuiltInAuxilliaryFunctions">
            <summary>
            <para>Only setting some flags will add some functions to beginning of OpenCL kernel string before compile</para>
            <para>Not implemented(yet)</para>
            </summary>
        </member>
        <member name="P:Cekirdekler.ClBuiltInHelper.ClBuiltInAuxilliaryFunctions.exampleFunction">
            <summary>
            adds "void exampleFunction(int a,int b){return a+b;}" in the beginning of kernel string
            </summary>
        </member>
        <member name="T:Cekirdekler.Pipeline.ClPipeline">
            <summary>
            <para>Explicit pipelining where each device works on a different stage of pipeline, concurrently, after each push()</para>
            <para>To be able to push at each iteration, double-buffering is used for inputs</para>
            <para>1 push      (1 thread) = (switch buffer):false</para>
            <para>1 more push (1 thread) = (switch buffer)(read+compute+write)[stage-0]:false</para>
            <para>1 more push (2 threads)= (switch buffer)(read+compute+write)[stage-0] ++ (switch buffer):false</para>
            <para>1 more push (2 threads)= (switch buffer)(read+compute+write)[stage-0] ++ (switch buffer)(read+compute+write)[stage-1]:true</para>
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.ClPipeline.pushData(System.Object[],System.Object[])">
            <summary>
            pushes data(arrays) from entrance stage, returns true if exit stage has result data on its output(and its target arrays)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Pipeline.ClPipeline.#ctor(System.Boolean)">
            <summary>
            only created by one of the stages that are bound together
            </summary>
        </member>
        <member name="T:Cekirdekler.Pipeline.ClPipelineStage">
            <summary>
            <para>used to build stages of a pipeline</para>
            <para>inputs are interpreted as read-only(partial if multi device stage), outputs are interpreted as write-only</para>
            <para>hidden buffers are used for sequential logic (keeping xyz coordinates of an nbody algorithm - for example) </para>
            <para>addition order of inputs,hiddens,outputs must be same as kernel arguments </para>
            <para>multiple inputs can be bound to a single output(copies same data to all inputs), opposite can't </para>
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.ClPipelineStage.#ctor(System.Boolean)">
            <summary>
            creates a stage to form a pipeline with other stages
            </summary>
        </member>
        <member name="P:Cekirdekler.Pipeline.ClPipelineStage.enqueueMode">
            <summary>
            enables enqueued execution of all kernels given as a list, false by default(not enabled)
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.ClPipelineStage.run(System.Boolean)">
            <summary>
            runs kernels attached to this stage consecutively (one after another)
            </summary>
            <param name="initializerKernels">runs only the initializer kernels given by initializerKernel() method</param>
        </member>
        <member name="M:Cekirdekler.Pipeline.ClPipelineStage.makePipeline">
            <summary>
            <para>creates a pipeline out of all bound stages, ready to compute, currently only 1 stage per layer (as parallel)</para>
            <para>executes the initializer kernels of each stage once</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Pipeline.ClPipelineStage.findInputStages">
            <summary>
            finds all stages and puts them in layers to be computed in parallel
            </summary>
            <param name="root"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Pipeline.ClPipelineStage.findOutputStagesCount(System.Int32)">
            <summary>
            finds total number of horizontally bound stages (also number of steps before output has data)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Pipeline.ClPipelineStage.initializerKernel(System.String,System.Int32[],System.Int32[])">
            <summary>
            <para>kernel function name to run once before beginning, empty string = no initializing needed</para>
            <para></para>
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.ClPipelineStage.prependToStage(Cekirdekler.Pipeline.ClPipelineStage)">
            <summary>
            binds this stage to target stage's entrance
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.ClPipelineStage.appendToStage(Cekirdekler.Pipeline.ClPipelineStage)">
            <summary>
            binds this stage to target stage's exit
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.ClPipelineStage.addDevices(Cekirdekler.Hardware.ClDevices)">
            <summary>
            <para>setup devices that will compute this stage(as parallel to speed-up this stage only, duplicated devices allowed too)</para>
            <para>copies device object</para>
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.ClPipelineStage.addKernels(System.String,System.String,System.Int32[],System.Int32[])">
            <summary>
            setup kernels to be used by this stage
            
            </summary>
            <param name="kernels">string containing auxiliary functions, kernel functions and constants</param>
            <param name="kernelNames">names of kernels to be used(in the order they run)</param>
            <param name="globalRanges">total workitems per kernel name in kernelNames parameter</param>
            <param name="localRanges">workgroup workitems per kernel name in kernelNames parameter</param>
        </member>
        <member name="M:Cekirdekler.Pipeline.ClPipelineStage.addHiddenBuffers(System.Array[])">
            <summary>
            not used for input or output, just for keeping sequential logic states (such as coordinates of particles)
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.ClPipelineStage.addHiddenBuffers(Cekirdekler.ClArrays.IBufferOptimization[])">
            <summary>
            not used for input or output, just for keeping sequential logic states (such as coordinates of particles)
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.ClPipelineStage.addHiddenBuffers(Cekirdekler.ClArrays.IMemoryHandle[])">
            <summary>
            not used for input or output, just for keeping sequential logic states (such as coordinates of particles)
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.ClPipelineStage.addInputBuffers(System.Array[])">
            <summary>
            input arrays (ClArray, ClByteArray, byte[], ... ) to be pushed by user or to be connect to another stage's output
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.ClPipelineStage.addInputBuffers(Cekirdekler.ClArrays.IBufferOptimization[])">
            <summary>
            input arrays (ClArray, ClByteArray, byte[], ... ) to be pushed by user or to be connect to another stage's output
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.ClPipelineStage.addInputBuffers(Cekirdekler.ClArrays.IMemoryHandle[])">
            <summary>
            input arrays (ClArray, ClByteArray, byte[], ... ) to be pushed by user or to be connect to another stage's output
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.ClPipelineStage.addOutputBuffers(System.Array[])">
            <summary>
            output arrays (ClArray, ClByteArray, byte[], ... ) to be popped to user or to be connected another stage's input
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.ClPipelineStage.addOutputBuffers(Cekirdekler.ClArrays.IMemoryHandle[])">
            <summary>
            output arrays (ClArray, ClByteArray, byte[], ... ) to be popped to user or to be connected another stage's input
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.ClPipelineStage.addOutputBuffers(Cekirdekler.ClArrays.IBufferOptimization[])">
            <summary>
            output arrays (ClArray, ClByteArray, byte[], ... ) to be popped to user or to be connected another stage's input
            </summary>
        </member>
        <member name="T:Cekirdekler.Pipeline.ClPipelineStageBuffer">
            <summary>
            Wraps Array, FastArr, ClArray types so that it can be switched by its duplicate, read, write, ...
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.ClPipelineStageBuffer.#ctor(System.Object,System.Boolean)">
            <summary>
            p: buffer to duplicate and double buffered in pipeline stages
            </summary>
            <param name="p"></param>
            <param name="duplicate"></param>
        </member>
        <member name="M:Cekirdekler.Pipeline.ClPipelineStageBuffer.switchBuffers">
            <summary>
            double buffering for pipelining(overlap pci-e reads and writes on all pci-e bridges)
            </summary>
        </member>
        <member name="T:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipeline">
            <summary>
            N staged pipeline.
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipeline.#ctor(Cekirdekler.Hardware.ClDevices,System.String,System.Int32)">
            <summary>
            N stages pipeline defined in a selected device
            </summary>
            <param name="selectedDevice">this can be a CPU, GPU, ...</param>
            <param name="kernelCodesC99">kernel string to be compiled for all stages</param>
            <param name="computeQueueConcurrency">max number of command queues to use asynchronously. max=16, min=1</param>
        </member>
        <member name="P:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipeline.queryTimelineOverlapPercentage">
            <summary>
            <para>not implemented yet</para>
            <para>enables query of begin-end time span data from all operations to get an idea of efficiency gained</para>
            </summary>
        </member>
        <member name="P:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipeline.stagesOverlappingPercentages">
            <summary>
            <para>not implemented yet</para>
            <para>if a stage was totally hidden in timeline by other stages, it has 100</para>
            <para>if a stage was not overlapped not even a bit, it has zero value</para>
            <para>each element of this int array indicates a stage in pipeline with same index/position</para>
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipeline.addStage(Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipelineStage)">
            <summary>
            add next stage at the end of current pipeline
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipeline.feed">
            <summary>
            <para>pushes data to entrance of pipeline, all stages run, pops results from end point
            </para>
            <param name="data">array of input parameters(arrays)</param>
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipeline.feedAsync(System.Delegate)">
            <summary>
            runs pipeline and executes a method given as parameter at the same time
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipeline.feedAsyncBegin">
            <summary>
            asynchronously starts enqueuing stages and synchronizes when feedAsyncEnd is called
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipeline.feedAsyncEnd">
            <summary>
            synchronizes the work started with feedAsyncEnd on host side, blocks until it finishes
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipeline.enableSerialMode">
            <summary>
            disables multi queue usage, serializes all operations, disables double buffering, result is computed immediately and ready at outputs
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipeline.enableParallelMode">
            <summary>
            enables multiple queues to compute all stages concurrently to maximize throughput with help of double buffering
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipeline.asyncHostWork">
            <summary>
            runs a C# host method asynchronously to OpenCL kernel, saves time 
            </summary>
        </member>
        <member name="T:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipelineStage">
            <summary>
            runs a kernel function at each pipeline feed() call using its inputs,outputs and internal arrays
            </summary>
        </member>
        <member name="P:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipelineStage.stopHostDeviceTransmission">
            <summary>
            <para> when set, this makes pipeline skip any future buffer read/write operations from host to device and device to host</para>
            <para> only for this pipeline stage instance </para>
            </summary>
        </member>
        <member name="P:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipelineStage.hasInput">
            <summary>
            returns true if this stage has any input array
            </summary>
        </member>
        <member name="P:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipelineStage.hasOutput">
            <summary>
            returns true if this stage has any output array
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipelineStage.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            runs kernel by name(s) with global-local workitem numbers
            </summary>
            <param name="kernelNames_"></param>
            <param name="globalRange_"></param>
            <param name="localRange_"></param>
        </member>
        <member name="M:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipelineStage.regroupParameters">
            <summary>
            <para>if there is single array, outputs it, if there are multiple array, returns ClParameterGroup</para>
            <para>regroups in the same order they were added, to be used in compute() kernel parameters</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipelineStage.switchBuffers">
            <summary>
            switches buffers with their duplicates()
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipelineStage.bindArray(Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipelineArray)">
            <summary>
            <para> binds an input, output or internal array to be used by kernel</para>
            <para> must be bound with the same order of kernel parameters</para>
            </summary>
        </member>
        <member name="T:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipelineArrayType">
            <summary>
            <para>input: read-only from kernel, write-only from host (uses read, not partial read)</para>
            <para>output: write-only from kernel, read-only from host (uses writeAll, not write)</para>
            <para>internal: only kernel accesses data, not duplicated</para>
            <para>transition: device side data flow between two stages</para>
            <para>partial/full access behavior could be changed later (optionally) from ClArray instance directly</para>
            </summary>
        </member>
        <member name="F:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipelineArrayType.INPUT">
            <summary>
            <para>read-only for kernel, write-only for host, duplicated for double buffering</para>
            <para>gets duplicated for double buffering for efficient communication</para>
            </summary>
        </member>
        <member name="F:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipelineArrayType.OUTPUT">
            <summary>
            <para>write-only for kernel, read-only for host, duplicated for double buffering</para>
            <para>gets duplicated for double buffering for efficient communication</para>
            </summary>
        </member>
        <member name="F:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipelineArrayType.INTERNAL">
            <summary>
            <para>only accessed by a stage's own kernel</para>
            <para>doesn't get duplicated for double buffering</para> 
            <para>used for sequential logic or as  accumulators</para>
            <para></para>
            </summary>
        </member>
        <member name="F:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipelineArrayType.TRANSITION">
            <summary>
            <para>binds two stages being an output of first one and an input of second one. </para>
            <para>gets duplicated for double buffering between two stages</para>
            </summary>
        </member>
        <member name="T:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipelineArray">
            <summary>
            pipeline stage arrays with behavior definition
            </summary>
        </member>
        <member name="P:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipelineArray.type">
            <summary>
            purpose of array. internal=sequential logic, input + output = combinational logic
            </summary>
        </member>
        <member name="P:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipelineArray.array">
            <summary>
            encapsulated array
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipelineArray.#ctor(Cekirdekler.Pipeline.SingleGPUPipeline.DevicePipelineArrayType,System.Object)">
            <summary>
            creates a pipeline buffer to be double-buffered for overlapped transmissions and computations
            </summary>
            <param name="type_"></param>
            <param name="array_">float[], byte[], ClArray, ClFloatArray, ClByteArray,...</param>
        </member>
        <member name="T:Cekirdekler.Pipeline.Pool.ClTaskType">
            <summary>
            <para>for building data-synchronization and similar "control" related tasks</para>
            <para>all types can be combined (for example, 32|16 shuts all devices down)</para>
            </summary>
        </member>
        <member name="F:Cekirdekler.Pipeline.Pool.ClTaskType.TASK_MESSAGE_DEFAULT">
            <summary>
            <para>does not do anything special</para>
            </summary>
        </member>
        <member name="F:Cekirdekler.Pipeline.Pool.ClTaskType.TASK_MESSAGE_DEVICE_SELECT_BEGIN">
            <summary>
            <para></para>
            <para>enables single device mode and selects a device for the following tasks until SELECT_END is reached.</para>
            <para>if SELECT_END is quickly enqueued on device, remaining tasks can be enqueued to other devices concurrently</para>
            <para>multiple select groups can run on different devices</para>
            <para>SELECT_END must exist between two SELECT_BEGIN. Multiple begin-end ranges must not overlap</para>
            <para>For every select-begin, there must be a select-end</para>
            </summary>
        </member>
        <member name="F:Cekirdekler.Pipeline.Pool.ClTaskType.TASK_MESSAGE_DEVICE_SELECT_END">
            <summary>
            <para></para>
            <para>deselects device of single device mode if it is enabled</para>
            <para>this does not ensure any synchronization between devices. Other devices can compute other groups of tasks</para>
            <para>SELECT_END must exist between two SELECT_BEGIN. Multiple begin-end ranges must not overlap</para>
            <para>For every select-begin, there must be a select-end</para>
            </summary>
        </member>
        <member name="F:Cekirdekler.Pipeline.Pool.ClTaskType.TASK_MESSAGE_GLOBAL_SYNCHRONIZATION_FIRST">
            <summary>
            <para>synchronizes a pool of devices which intercepts this task before passing it to a device</para>
            <para>if pool contains kernels from 1 to 10 and if 5 is synced, kernels from 1 to 4 are ensured to finish before 5 to 10 starts</para>
            </summary>
        </member>
        <member name="F:Cekirdekler.Pipeline.Pool.ClTaskType.TASK_MESSAGE_GLOBAL_SYNCHRONIZATION_LAST">
            <summary>
            <para>synchronizes a pool of devices after a device consumes this task</para>
            </summary>
        </member>
        <member name="F:Cekirdekler.Pipeline.Pool.ClTaskType.TASK_MESSAGE_BROADCAST">
            <summary>
            <para>runs this task on all devices when device pool intercepts this</para>
            <para>must not write to host(array.write or array.writeAll must not be enabled)</para>
            <para>meant for only initializing all devices' buffers, read-only, even on kernel side</para>
            <para></para>
            </summary>
        </member>
        <member name="F:Cekirdekler.Pipeline.Pool.ClTaskType.TASK_MESSAGE_NO_COMPUTE">
            <summary>
            <para>not implemeneted</para>
            <para>only device-host buffer copies will be enqueued</para>
            </summary>
        </member>
        <member name="F:Cekirdekler.Pipeline.Pool.ClTaskType.TASK_MESSAGE_SERIAL_MODE_BEGIN">
            <summary>
            <para>same as DEVICE_SELECT_BEGIN but selects a queue too</para>
            <para>runs all tasks one after another in-order in same queue in same device</para>
            <para>must not overlap any other BEGIN-END range</para>
            <para>does not need DEVICE_SELECT_BEGIN</para>
            <para>only fine grained control mode needs this</para>
            </summary>
        </member>
        <member name="F:Cekirdekler.Pipeline.Pool.ClTaskType.TASK_MESSAGE_SERIAL_MODE_END">
            <summary>
            <para>same as DEVICE_SELECT_END but selects a queue too</para>
            <para>runs all tasks one after another in-order in same queue in same device</para>
            <para>must not overlap any other BEGIN-END range</para>
            <para>does not need DEVICE_SELECT_END</para>
            <para>only fine grained control mode needs this</para>
            </summary>
        </member>
        <member name="F:Cekirdekler.Pipeline.Pool.ClTaskType.TASK_MESSAGE_LAST">
            <summary>
            only for internal work, don't use
            </summary>
        </member>
        <member name="T:Cekirdekler.Pipeline.Pool.ClTask">
            <summary>
            <para>a piece of work to be done later</para>
            <para>contains necessary info to complete a array.compute() operation</para>
            <para>ClArray.task() ClParameterGroup.task()</para>
            <para>is meant to be computed later in a pool(of tasks) by a pool of devices(each device compute a single task at a time or a part of it)</para>
            <para>main advantage is to stop code duplication where a lot of read/write state changes are needed between compute() operations</para>
            <para>secondary advantage is to automate device selection for a group of tasks within pools</para>
            </summary>
        </member>
        <member name="P:Cekirdekler.Pipeline.Pool.ClTask.type">
            <summary>
            additional role(or combined roles) of this task
            </summary>
        </member>
        <member name="P:Cekirdekler.Pipeline.Pool.ClTask.kernelRepeats">
            <summary>
            not implemented yet
            </summary>
        </member>
        <member name="P:Cekirdekler.Pipeline.Pool.ClTask.kernelRepeatName">
            <summary>
            not implemented yet
            </summary>
        </member>
        <member name="P:Cekirdekler.Pipeline.Pool.ClTask.callbackFunctionToRun">
            <summary>
            function to run after task is complete
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.Pool.ClTask.compute(Cekirdekler.ClNumberCruncher)">
            <summary>
            computes this task using the given number cruncher
            </summary>
            <param name="numberCruncher"></param>
        </member>
        <member name="M:Cekirdekler.Pipeline.Pool.ClTask.#ctor(Cekirdekler.ClArrays.ICanCompute,System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Int32,System.String[],System.Int32[])">
            <summary>
            only ClParameterGroup or a ClArray can create this
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.Pool.ClTask.setCallBack(System.Delegate)">
            <summary>
            runs a given function after task is completed
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.Pool.ClTask.deviceBarrier">
            <summary>
            <para>not implemented</para>
            <para>when this task arrives at a (single)device, ensures synchronization on all queues of it</para>
            <para>useful for only getting random partial results before pool completes</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Pipeline.Pool.ClTask.globalBarrier">
            <summary>
            <para>not implemented</para>
            <para>when this task is intercepted by device pool(not devices), it ensures synchronization on all devices</para>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Cekirdekler.Pipeline.Pool.ClTaskGroupType">
            <summary>
            type of task group that defines execution behavior of all of its tasks
            </summary>
        </member>
        <member name="F:Cekirdekler.Pipeline.Pool.ClTaskGroupType.TASK_COMPLETE">
            <summary>
            <para>all devices work for this task group until all tasks in it are completed</para>
            <para>this is default value</para>
            <para></para>
            </summary>
        </member>
        <member name="F:Cekirdekler.Pipeline.Pool.ClTaskGroupType.TASK_ASYNC">
            <summary>
            <para>all devices are free to pick tasks from this task group or any other group</para>
            <para>suitable for combinatorial logic based pipelines and independent workloads</para>
            <para>a case of nbody+image processing+fluid dynamics being in same group is an example</para>
            <para>the only advantage compared to non-grouped tasks is: WORK_ROUND_ROBIN type device pools will issue groups equally</para>
            <para>so two different workloads can be given equal priority without defining any priority value</para>
            </summary>
        </member>
        <member name="F:Cekirdekler.Pipeline.Pool.ClTaskGroupType.TASK_SAME_DEVICE">
            <summary>
            <para>all tasks in a group is executed in same device always</para>
            <para>doesn't guarantee to run on same device if repeated</para>
            <para>doesn't guarantee to run tasks in the order they were added</para>
            </summary>
        </member>
        <member name="F:Cekirdekler.Pipeline.Pool.ClTaskGroupType.TASK_REPEAT_SAME_DEVICE">
            <summary>
            <para>repeating same task group is done by same device always</para>
            <para>doesn't guarantee to run tasks in the order they were added</para>
            <para>suitable for pipelines</para>
            </summary>
        </member>
        <member name="F:Cekirdekler.Pipeline.Pool.ClTaskGroupType.TASK_IN_ORDER">
            <summary>
            <para>all tasks in group is issued into same command queue of same device</para>
            <para>every next task in group sees the updated bits of latest issued task in terms of memory consistency</para>
            <para>running commands in an in-order queue is always synchronized before next command, on device side(kernels) and host side(buffer copy)</para>
            <para>repeating a group doesn't guarantee same device nor same command queue</para>
            </summary>
        </member>
        <member name="F:Cekirdekler.Pipeline.Pool.ClTaskGroupType.TASK_REPEAT_IN_ORDER">
            <summary>
            <para>all tasks in group is issued into same command queue of same device</para>
            <para>every next task in group sees the updated bits of latest issued task in terms of memory consistency</para>
            <para>running commands in an in-order queue is always synchronized before next command, on device side(kernels) and host side(buffer copy)</para>
            <para>repeating a group guarantees same device and same command queue to run</para>
            <para>for WORK_ROUND_ROBIN enabled device pools, there may be a different task group's tasks between any two tasks of current group in a command queue</para>
            </summary>
        </member>
        <member name="T:Cekirdekler.Pipeline.Pool.ClTaskGroup">
            <summary>
            <para>a group of tasks to be computed with same execution behavior</para>
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.Pool.ClTaskGroup.#ctor(Cekirdekler.Pipeline.Pool.ClTaskGroupType)">
            <summary>
            <para>a group of tasks to be computed with same execution behavior</para>
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.Pool.ClTaskGroup.add(Cekirdekler.Pipeline.Pool.ClTask)">
            <summary>
            adds a new task
            </summary>
            <param name="task"></param>
        </member>
        <member name="T:Cekirdekler.Pipeline.Pool.ClTaskPool">
            <summary>
            <para>a pool of tasks to be computed by a pool of devices with optional scheduling algorithms</para>
            <para>re-usable with resetting inner counter</para>
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.Pool.ClTaskPool.#ctor">
            <summary>
            creaetes a pool that receives tasks
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.Pool.ClTaskPool.reset">
            <summary>
            clears task counter and makes this pool re-usable again
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.Pool.ClTaskPool.feed(Cekirdekler.Pipeline.Pool.ClTask)">
            <summary>
            <para>pushes a duplicated instance of given ClTask instance to one end of queue to compute later</para>
            <para>compute operations are issued from other end of queue</para>
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.Pool.ClTaskPool.nextTask">
            <summary>
            get next task in the list
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.Pool.ClTaskPool.remainingTaskGroupsOrTasks">
            <summary>
            returns number of tasks(and groups) left
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Pipeline.Pool.ClTaskPool.feed(Cekirdekler.Pipeline.Pool.ClTaskGroup)">
            <summary>
            <para>pushes a new ClTaskGroup instance to one end of queue to compute later</para>
            <para>compute operations are issued from other end of queue</para>
            </summary>
        </member>
        <member name="T:Cekirdekler.Pipeline.Pool.ClDevicePoolType">
            <summary>
            <para>to pick a specific scheduler algorithm</para>
            <para>WORKER_ and WORK_ prefixed types can be combined with OR</para>
            </summary>
        </member>
        <member name="F:Cekirdekler.Pipeline.Pool.ClDevicePoolType.DEVICE_COMPUTE_AT_WILL">
            <summary>
            <para>whenever a device becomes ready after computing a task, immediately issues another task</para>
            <para>better for asymmetric GPUs</para>
            <para>default value</para>
            </summary>
        </member>
        <member name="F:Cekirdekler.Pipeline.Pool.ClDevicePoolType.DEVICE_ROUND_ROBIN">
            <summary>
            <para>not implemented yet</para>
            <para>a device in pool issues a task, then next task is issued by next device only</para>
            <para>better for identical devices</para>
            </summary>             
        </member>
        <member name="T:Cekirdekler.Pipeline.Pool.ClDevicePool">
            <summary>
            <para>instead of working for same workload (as in ClNumberCruncher class)</para>
            <para>this container specializes to distribute work independently to differend devices</para>
            <para>uses a multitude of scheduling algorithms</para>
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.Pool.ClDevicePool.#ctor(Cekirdekler.Pipeline.Pool.ClDevicePoolType,System.String,System.Boolean,System.Int32)">
            <summary>
            <para>creates a worker pool with a type</para>
            <para>any ClNumberCruncher instance added to this pool will work accordingly with the type algorithm</para>
            </summary>
            <param name="poolType"></param>
            <param name="kernelCodeToCompile"></param>
            <param name="fineGrainedQueueControlParameter">
            <para>on-flight device feed speed adjustment</para>
            <para>true: enables event-callback based task feed adjustment without and slow host synchronization</para>
            <para>default:false</para>
            <para>false: every task is synchronized on host, better balancing between devices, low "many-task" performance</para>
            </param>
            <param name="maxQueuesPerDevice">limits number of queues per device. must be between 1 and 16 inclusive</param>
        </member>
        <member name="M:Cekirdekler.Pipeline.Pool.ClDevicePool.produceTasksComputeAtWill">
            <summary>
            producer-consumer work flow's producer part that distributes tasks
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.Pool.ClDevicePool.addDevice(Cekirdekler.Hardware.ClDevices)">
            <summary>
            <para>add a device to pool</para>
            <para>can add in the middle of computation of a task pool</para>
            <para>compilation of kernels can take some time</para>
            <para>adds a new consumer thread for each new (logical) device instance.</para> 
            <para>same device can be added multiple times, if there are enough resources in OpenCL side</para>
            </summary>
            <param name="devicesParameter"></param>
        </member>
        <member name="M:Cekirdekler.Pipeline.Pool.ClDevicePool.enqueueTaskPool(Cekirdekler.Pipeline.Pool.ClTaskPool)">
            <summary>
            <para>enqueues a (deeply copied)duplicate of taskPoolParameter(task pool) to this device pool</para>
            <para>older pools reside until completed(their queues and containers empty)</para>
            <para>a device may choose a different pool for next task, depending on the task pool type</para>
            <para>this re-initiates producer part</para>
            <para>enqueues a duplicate of taskPoolParameter so </para>
            </summary>
            <param name="taskPoolParameter"></param>
        </member>
        <member name="M:Cekirdekler.Pipeline.Pool.ClDevicePool.finish">
            <summary>
            <para>waits until all tasks are complete</para>
            <para>returns milliseconds elapsed</para>
            </summary>
        </member>
        <member name="M:Cekirdekler.Pipeline.Pool.ClDevicePool.dispose">
            <summary>
            disposes devices
            </summary>
        </member>
        <member name="T:Cekirdekler.Pipeline.Pool.ClPoolTaskQueue">
            <summary>
            queue for producer-consumer
            </summary>
        </member>
        <member name="T:Cekirdekler.Cores">
            <summary>
            <para>main part of the API. Binds devices to platforms, buffers to arrays, commandqueues to commands</para>
            <para>can pipeline kernel as many sub works that are issued concurrently</para>
            <para>can load-balance between gpus, cpus and accelerators</para>
            </summary>
        </member>
        <member name="P:Cekirdekler.Cores.noComputeMode">
            <summary>
            <para>just to upload/download data on GPU without any compute operation</para>
            <para>specifically used for single gpu pipelining with enqueue mode for input-output stages overlapping</para>
            <para>not for driver/event pipelining </para>
            <para>with or without multiple gpus, it skips compute part and directly does data transmissions</para>
            </summary>
        </member>
        <member name="P:Cekirdekler.Cores.enqueueModeAsyncEnable">
            <summary>
            <para>only for single gpu(or device to device pipeline stages)  and not for driver/event pipelining </para>
            <para>used by enqueueMode to distribute each compute job to a different queue or not</para>
            <para>true=distribute each compute to a different queue</para>
            <para>false=use single queue for all jobs</para>
            </summary>
        </member>
        <member name="P:Cekirdekler.Cores.enqueueMode">
            <summary>
            <para>only for single gpu (or device to device pipeline stages) and not for driver/event pipelining </para>
            <para>not usable with host-device pipeline</para>
            <para>kernel-array matrix must not change during in enqueue mode(setting kernel arguments are not "enqueue" command)</para>
            <para>arrays from host must not change during enqueue mode</para>
            <para>true=disables commandQueue synchronization</para>
            <para>false=enables commandQueue synchronization again and setting to false synchronizes host-device immediately</para>
            </summary>
        </member>
        <member name="F:Cekirdekler.Cores.globalRanges">
            <summary>
            global range values for opencl per device per compute id
            </summary>
        </member>
        <member name="F:Cekirdekler.Cores.globalReferences">
            <summary>
            global reference points for ranges for opencl per device per compute id
            </summary>
        </member>
        <member name="P:Cekirdekler.Cores.allErrorsString">
            <summary>
            contains C99 kernel compiler errors returned from all devices
            </summary>
        </member>
        <member name="M:Cekirdekler.Cores.#ctor(System.String,System.String,System.String[],System.Boolean,System.Int32,System.Int32,System.Boolean,System.Int32,System.Boolean)">
            <summary>
            Main class for scheduling device queues and controlling work distributions
            </summary>
            <param name="deviceTypesToUse">"cpu" "gpu" "cpu gpu" "gpu acc" ...</param>
            <param name="kernelFileString"></param>
            <param name="kernelFunctionNamesInKernelFileString"></param>
            <param name="defaultQueue">OpenCL dynamic parallelism queue</param>
            <param name="localRangeDeprecated"></param>
            <param name="numGPUToUse">if pc has 4 gpu, can set this to 4</param>
            <param name="MAX_CPU">-1 = MAX - 1, max( min(MAX_CPU,MAX-1),1) </param>
            <param name="GPU_STREAM">default is true: map - unmap instead of extra read-write for all devices</param>
            <param name="noPipelining">disables allocation of abundant command queues(can't enable driver-driver pipelining later)</param>
        </member>
        <member name="M:Cekirdekler.Cores.#ctor(Cekirdekler.Hardware.ClDevices,System.String,System.String[],System.Boolean,System.Int32,System.Boolean)">
            <summary>
            Main class for scheduling device queues and controlling work distributions
            </summary>
            <param name="devicesForGPGPU">device or a group of devices to use in gpgpu calculations</param>
            <param name="kernelFileString"></param>
            <param name="kernelFunctionNamesInKernelFileString"></param>
            <param name="defaultQueue">OpenCL 2.0 dynamic parallelism queue</param>
            <param name="noPipelining">disables allocation of abundant command queues(can't enable driver-driver pipelining later)</param>
            <param name="computeQueueConcurrency">max number of command queues to send commands asynchronously(max=16,min=1)</param>
        </member>
        <member name="M:Cekirdekler.Cores.numberOfDevices">
            <summary>
            1 worker per device (each worker can have concurrent pipelining if enabled)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Cores.errorMessage">
            <summary>
            error description from compiler
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Cores.errorCode">
            <summary>
            different from zero means error
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Cores.pinArray(System.Object)">
            <summary>
            pin C# arrays in place for compute so they don't move while computing, doesn't touch C++ arrays 
            </summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="F:Cekirdekler.Cores.PIPELINE_EVENT">
            <summary>
            <para>a network of opencl events controls multiple commandqueues so read is done concurrently with compute and write</para>
            <para>hides the least time consuming part(read or compute or write) latency behind the most time consuming part(read or compute or write)</para>
            <para>2 command queues issue read(from array) operations</para>
            <para>2 command queues issue compute operations</para>
            <para>2 command queues issue write(to array) operations</para>
            <para>pipeline parts mush be minimum 4 and be multiple of 4</para>
            </summary>
        </member>
        <member name="F:Cekirdekler.Cores.PIPELINE_DRIVER">
            <summary>
            <para>no opencl event is used. the driver controls scheduling for the optimum multi-commandqueue work overlapping</para>
            <para>16 command queues are used, each one has (read + compute + write) of a small portion of whole work</para>
            <para>pipeline parts mush be minimum 4 and be multiple of 4</para>
            </summary>
        </member>
        <member name="P:Cekirdekler.Cores.smoothLoadBalancer">
            <summary>
            smoothing of load balancing to take care of performance spikes and OS hiccups and similar
            </summary>
        </member>
        <member name="P:Cekirdekler.Cores.fineGrainedQueueControl">
            <summary>
            <para>true = a marker is added to the used command queue and a callback increments a counter for that command queue</para>
            <para>total count is queried by countMarkers()</para>
            <para>total reached markers are queried by countMarkerCallbacks()</para>
            <para>so the remaining markers are countMarkers() - countMarkerCallbacks()</para>
            <para>has performance penalty for many repeated light workload kernels (2-3 microseconds gap becomes 200-300 microseconds)</para>
            </summary>
        </member>
        <member name="M:Cekirdekler.Cores.compute(System.String[],System.Int32,System.String,System.Object[],System.String[],System.Int32[],System.Int32,System.Int32,System.Int32,System.Boolean,System.Int32,System.Boolean,System.Int32)">
            <summary>
            
            </summary>
            <param name="kernelNames">names of kernels to be executed consecutively</param>
            <param name="numRepeats">repeats(0=no repeat, 1=once, n=n times) kernels with a sync kernel at the end of each repeat step</param>
            <param name="syncKernelName">after n different kernels, a sync kernel is executed if numRepeats>0 </param>
            <param name="arrs">C#(float[],int[],...) or C++ arrays(FastArr, ClArray)</param>
            <param name="readWrite">"partial read": each device reads its own territory(possibly pipelined), "read": all devices read all at once,"write": all devices write their own results(possibly pipelined),"write all": only single device writes all arrays at once, without checking size</param>
            <param name="elementsPerWorkItem">number of array elements that each workitem alters,reads or writes(if kernel alters randomly,using "partial" (in readWrite) is undefined behaviour)</param>
            <param name="globalRange">total workitems to be distributed to all selected devices</param>
            <param name="computeId">compute id value, determines that this operation is similar to or different than any other compute(to distribute workitems better iteratively)</param>
            <param name="globalOffset">(shifts all workitem right by this number(for cluster extension))first device in load-balance always starts from zero unless this variable is set to x>0 </param>
            <param name="pipelineEnabled">enables multi-commandqueue compute to hide latencies. example: if read takes %33, compute takes %33, write takes %33 of time, then pipelining makes it 3x as fast</param>
            <param name="numberOfPipelineStages">minimum 4, multiple of 4</param>
            <param name="pipelineType">PIPELINE_EVENT(6 queues, read-write-compute separated) or PIPELINE_DRIVER(16 queues, read-compute-write together)</param>
            <param name="localRange">local range value (number of workitems per group) for all devices</param>
        </member>
        <member name="M:Cekirdekler.Cores.performanceReport(System.Int32)">
            <summary>
            outputs to console: execution times per device and devices' target memory types(dedicated or RAM)
            </summary>
            <param name="computeId">compute id of compute action to be profiled. a compute action may behave differently than others because of data difference, kernel difference, read-write difference</param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Cores.performanceHistory(System.Int32)">
            <summary>
            get performance old values for smoothing load balancer, making OS peaks less effective
            </summary>
            <param name="computeId"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Cores.benchmarks(System.Int32)">
            <summary>
            execution timings of all devices for all compute id values
            </summary>
            <param name="computeId"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Cores.deviceNames">
            <summary>
            returns device names such as 8-core desktop cpu or pitcairn or oland or Intel HD 400
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Cores.Finalize">
            <summary>
            releases C++ resources
            </summary>
        </member>
        <member name="M:Cekirdekler.Cores.dispose">
            <summary>
            release C++ resources
            </summary>
        </member>
        <member name="T:Cekirdekler.AcceleratorType">
            <summary>
            CPU|GPU means all GPUs and all CPUs
            GPU|ACC means all GPUs and all ACCs
            GPU means only GPUs are used
            </summary>
        </member>
        <member name="F:Cekirdekler.AcceleratorType.CPU">
            <summary>
            only selects CPUs
            </summary>
        </member>
        <member name="F:Cekirdekler.AcceleratorType.GPU">
            <summary>
            only selects GPUs and iGPUs
            </summary>
        </member>
        <member name="F:Cekirdekler.AcceleratorType.ACC">
            <summary>
            special accelerators
            </summary>
        </member>
        <member name="T:Cekirdekler.ClNumberCruncher">
            <summary>
            compiles kernel strings for the selected devices then computes with array(C#,C++) parameters later 
            </summary>
        </member>
        <member name="P:Cekirdekler.ClNumberCruncher.noComputeMode">
            <summary>
            <para>just to upload/download data on GPU without any compute operation</para>
            <para>specifically used for single gpu pipelining with enqueue mode for input-output stages overlapping</para>
            <para>not for driver/event pipelining </para>
            <para>with or without multiple gpus, it skips compute part and directly does data transmissions</para>
            </summary>
        </member>
        <member name="P:Cekirdekler.ClNumberCruncher.fineGrainedQueueControl">
            <summary>
            <para>to watch command queues with finer grained resolution</para>
            <para>true = a marker is added to the last used command queue</para>
            <para>a callback is triggered when a marker is reached, to increment counter for that command queue</para>
            <para>total count is queried by countMarkers()</para>
            <para>total reached markers are queried by countMarkerCallbacks()</para>
            <para>so the remaining markers are countMarkers() - countMarkerCallbacks()</para>
            <para>high performance penalty for many repeated light workload kernels (2-3 microseconds gap becomes 150-200 microseconds)</para>
            </summary>
        </member>
        <member name="M:Cekirdekler.ClNumberCruncher.flushLastUsedCommandQueue">
            <summary>
            for a more fine-grained host control with enqueue mode, 
            this can be used as a forced command issue to device
            that flushes last used command queue
            </summary>
        </member>
        <member name="P:Cekirdekler.ClNumberCruncher.enqueueModeAsyncEnable">
            <summary>
            <para>only for single gpu(or device to device pipeline stages)</para>
            <para>used by enqueueMode to distribute each compute job to a different queue or not</para>
            <para>true=distribute each compute to a different queue</para>
            <para>false=use single queue for all jobs</para>
            </summary>
        </member>
        <member name="P:Cekirdekler.ClNumberCruncher.enqueueMode">
            <summary>
            <para>true: no synchronization between host and device so "used arrays" shouldn't be accessed from host(or other devices). </para>
            <para>false: safe to access arrays from host(or other devices) side</para>
            <para>kernel argument change or any change of order of arrays for a kernel will result in an instant synchronization </para>
            </summary>
        </member>
        <member name="M:Cekirdekler.ClNumberCruncher.sync">
            <summary>
            triggers all command queues synchronizations(so they finish all enqueued commands) and completes host-device synchronizations
            </summary>
        </member>
        <member name="P:Cekirdekler.ClNumberCruncher.repeatCount">
            <summary>
            <para>number of repeats for a kernel or a list of kernels</para> 
            <para>to decrease unnecessary synchronization points</para>
            <para>to make latency better</para>
            <para>disables host-to-device pipelining(which is enabled with compute() parameters)</para>
            <para> when value > 1, it enables repeatKernelName usage </para>
            </summary>
        </member>
        <member name="P:Cekirdekler.ClNumberCruncher.repeatKernelName">
            <summary>
            <para> when repeatCount>1, this kernel is added to the end of kernel list in compute()</para>
            <para> enqueued once at each iteration of repeat </para>
            <para> enqueued with global size = local size so it costs minimal latency to alter a few variables between repeats</para>
            <para> when not "", disables host-to-device pipelining(which is enabled with compute() parameters)</para>
            <para> usaes same parameters with main kernel execution </para>
            </summary>
        </member>
        <member name="P:Cekirdekler.ClNumberCruncher.performanceFeed">
            <summary>
            outputs to console: each device's performance(and memory target type) results per compute() operation
            </summary>
        </member>
        <member name="M:Cekirdekler.ClNumberCruncher.lastComputePerformanceReport">
            <summary>
            outputs last execution performance
            </summary>
        </member>
        <member name="P:Cekirdekler.ClNumberCruncher.smoothLoadBalancer">
            <summary>
            to ease balancing against performance spikes, interrupts, hiccups
            </summary>
        </member>
        <member name="M:Cekirdekler.ClNumberCruncher.#ctor(Cekirdekler.AcceleratorType,System.String,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            <para>prepares devices and compiles kernels in the kernel string</para>
            <para>does optionally pipelined kernel execution load balancing between multiple devices</para>
            </summary>
            <param name="cpuGpu">AcceleratorType.CPU|AcceleratorType.GPU or similar</param>
            <param name="kernelString">something like: @"multi-line C# string that has multiple kernel definitions"</param>
            <param name="numberofCPUCoresToUseAsDeviceFission">AcceleratorType.CPU uses number of threads for an N-core CPU(between 1 and N-1)(-1 means N-1)</param>
            <param name="numberOfGPUsToUse">AcceleratorType.GPU uses number of GPUs equal to this parameter. Between 1 and N(-1 means N)</param>
            <param name="stream">devices that share RAM with CPU will not do extra copies. Devices that don't share RAM will directly access RAM and reduce number of copies</param>
            <param name="noPipelining">disables extra command queue allocation, can't enable driver-driven pipelining later. Useful for device to device pipelining with many stages.</param>
        </member>
        <member name="M:Cekirdekler.ClNumberCruncher.normalizedComputePowersOfDevices">
            <summary>
            returns relative compute power of each device
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClNumberCruncher.normalizedGlobalRangesOfDevices(System.Int32)">
            <summary>
            returns relative global range of each device
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClNumberCruncher.deviceNames">
            <summary>
            list of devices' names
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClNumberCruncher.#ctor(Cekirdekler.Hardware.ClDevices,System.String,System.Boolean,System.Int32)">
            <summary>
            <para>prepares devices and compiles kernels in the kernel string</para>
            <para>does optionally pipelined kernel execution load balancing between multiple devices</para>
            </summary>
            <param name="devicesForGPGPU">one or more devices for GPGPU</param>
            <param name="kernelString">something like: @"multi-line C# string that has multiple kernel definitions"</param>
            <param name="noPipelining">disables extra command queue allocation, can't enable driver-driven pipelining later. Useful for device to device pipelining with many stages.</param>
            <param name="computeQueueConcurrency">max number of command queues to send commands asynchronously, max=16, min=1</param>
        </member>
        <member name="M:Cekirdekler.ClNumberCruncher.countMarkersRemaining">
            <summary>
            <para>counts all remaining markers to reach in all command queues in all devices</para>
            <para>for finer grained scheduling/control</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClNumberCruncher.countMarkersReached">
            <summary>
            number of markers reached
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClNumberCruncher.errorMessage">
            <summary>
            kernel compile error
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClNumberCruncher.errorCode">
            <summary>
            not zero means error
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClNumberCruncher.dispose">
            <summary>
            releases C++ resources
            </summary>
        </member>
        <member name="M:Cekirdekler.ClNumberCruncher.Finalize">
            <summary>
            releases C++ resources
            </summary>
        </member>
        <member name="T:Cekirdekler.ClArrays.ICanCompute">
            <summary>
            Parameter group to be crunched in kernel execution
            </summary>
        </member>
        <member name="M:Cekirdekler.ClArrays.ICanCompute.compute(Cekirdekler.ClNumberCruncher,System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Int32,System.String[],System.Int32[])">
            <summary>
            <para>blocking compute operation that does read + compute + write </para>
            </summary>
            <param name="cruncher"></param>
            <param name="computeId"></param>
            <param name="kernelNamesString">string that contains all kernel names(to be executed) separated by space or by , or by ;</param>
            <param name="globalRange">total workitems to be distributed to devices</param>
            <param name="localRange">workitems per local workgroup. default value is 256</param>
            <param name="ofsetGlobalRange">starting id for workitems.(for cluster add-on)</param>
            <param name="pipeline">true: kernel-partializing pipeline is on (this is out of OpenCL 1.2 specs so use at your own risk)</param>
            <param name="pipelineType">Cores.PIPELINE_EVENT means event-driven 3-queued pipelined read+compute+write operation. </param>
            <param name="pipelineBlobs">minimum 4, multiple of 4</param>
            <param name="readWritesReady">
            <para>used by ClTask. compute() uses predetermined array fields in this array instead of current values.</para>
            <para>null = current values will be used</para>
            </param>
            <param name="elementsPerItemReady">
            <para>used by ClTask. compute() uses predetermined per-item-elements-value in this array instead of current values.</para>
            <para>null = current values will be used</para>
            </param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ICanCompute.task(System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            <para>creates task to compute later, meant to be used in pools mainly</para>
            </summary>
            <param name="cruncher"></param>
            <param name="computeId"></param>
            <param name="kernelNamesString">string that contains all kernel names(to be executed) separated by space or by , or by ;</param>
            <param name="globalRange">total workitems to be distributed to devices</param>
            <param name="localRange">workitems per local workgroup. default value is 256</param>
            <param name="ofsetGlobalRange">starting id for workitems.(for cluster add-on)</param>
            <param name="pipeline">true: pipeline is on</param>
            <param name="pipelineType">Cores.PIPELINE_EVENT means event-driven 3-queued pipelined read+compute+write operation. </param>
            <param name="pipelineBlobs">minimum 4, multiple of 4</param>
        </member>
        <member name="T:Cekirdekler.ClArrays.IBufferOptimization">
            <summary>
            can optimize the buffer copies 
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.IBufferOptimization.array">
            <summary>
            array to be used in computations. could be a C# array or FastArr{T} as a wrapper for C++ array 
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.IBufferOptimization.zeroCopy">
            <summary>
            <para>if the device used in cruncher supports zero copy buffer access, this field determines its usage. true=direct RAM access, false=dedicated memory</para>
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.IBufferOptimization.readOnly">
            <summary>
            <para>buffers created in devices will be read by kernel and written by host, always</para>
            <para>prevents usage of write/writeAll/writeOnly, until it is set to false again</para>
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.IBufferOptimization.writeOnly">
            <summary>
            <para>buffers created in devices will be written by kernel and read by host, always</para>
            <para>prevents usage of read/partialRead/readOnly, until its set to false again</para>
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.IBufferOptimization.read">
            <summary>
            read whole array before compute
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.IBufferOptimization.partialRead">
            <summary>
            <para>change the read into a partial type so it can be pipelined to hide latency to make compute() faster (possibly pipelined)</para>
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.IBufferOptimization.write">
            <summary>
            writes partial results after kernel execution (possibly pipelined)
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.IBufferOptimization.writeAll">
            <summary>
            write results after kernel execution but all of array instead of a part of it
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.IBufferOptimization.arrayLength">
            <summary>
            just to return typeof(T) instead of using many if-else in client code
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.IBufferOptimization.numberOfElementsPerWorkItem">
            <summary>
            <para>number of array elements per workitem to be computed, to be buffer-copied. default=1</para>
            <para>also default=1 for C# arrays(without ClArray nor FastArr )</para>
            <para>number of global workitems * elements per work item must not be greater than buffer size </para>
            <para>number of local workitems * elements per work item * number of pipeline blob must not be greater than buffer size  </para>
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.IBufferOptimization.alignmentBytes">
            <summary>
            if contained array is a C++ array, this value is the address alignment of it in bytes
            </summary>
        </member>
        <member name="T:Cekirdekler.ClArrays.ClParameterGroup">
            <summary>
            Holds ClArray instances, C# arrays and FastArr instances to be computed later
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClParameterGroup.array">
            <summary>
            not implemented
            </summary>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClParameterGroup.selectedArrays">
            <summary>
            linked list to array conversion for all arrays
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClParameterGroup.nextParam(System.Array[])">
            <summary>
            <para>adds arrays as more parameters for kernel execution</para>
            <para>arrays order as parameters:</para>
            <para>this object - then - other params added to this object - then - parameters from .nextParam()</para>
            </summary>
            <param name="arrays_">C# arrays to add as kernel parameters</param>
            <returns>a ClParameterGroup that can crunch numbers or bind more parameters</returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClParameterGroup.nextParam(Cekirdekler.ClArrays.IMemoryHandle[])">
            <summary>
            <para>adds arrays as more parameters for kernel execution</para>
            <para>arrays order as parameters:</para>
            <para>this object - then - other params added to this object - then - parameters from .nextParam()</para>
            </summary>
            <param name="arrays_">FastArr type(ClFloatArray,ClUIntArray,...) arrays to add as kernel parameters</param>
            <returns>a ClParameterGroup that can crunch numbers or bind more parameters</returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClParameterGroup.nextParam(Cekirdekler.ClArrays.IBufferOptimization[])">
            <summary>
            <para>adds arrays as more parameters for kernel execution</para>
            <para>arrays order as parameters:</para>
            <para>this object - then - other params added to this object - then - parameters from .nextParam()</para>
            </summary>
            <param name="arrays_">ClArray type arrays(which can wrap C# or C++ arrays) to add as kernel parameters</param>
            <returns>a ClParameterGroup that can crunch numbers or bind more parameters</returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClParameterGroup.nextParam(Cekirdekler.ClArrays.ClParameterGroup[])">
            <summary>
            <para>adds arrays as more parameters for kernel execution</para>
            <para>arrays order as parameters:</para>
            <para>this object - then - other params added to this object - then - parameters from .nextParam()</para>
            </summary>
            <param name="parameterGroups_">Other parameter groups to add as kernel parameters</param>
            <returns>a ClParameterGroup that can crunch numbers or bind more parameters</returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClParameterGroup.task(System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            <para>creates task to compute later, meant to be used in pools mainly</para>
            </summary>
            <param name="cruncher"></param>
            <param name="computeId"></param>
            <param name="kernelNamesString">string that contains all kernel names(to be executed) separated by space or by , or by ;</param>
            <param name="globalRange">total workitems to be distributed to devices</param>
            <param name="localRange">workitems per local workgroup. default value is 256</param>
            <param name="ofsetGlobalRange">starting id for workitems.(for cluster add-on)</param>
            <param name="pipeline">true: pipeline is on</param>
            <param name="pipelineType">Cores.PIPELINE_EVENT means event-driven 3-queued pipelined read+compute+write operation. </param>
            <param name="pipelineBlobs">minimum 4, multiple of 4</param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClParameterGroup.compute(Cekirdekler.ClNumberCruncher,System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Int32,System.String[],System.Int32[])">
            <summary>
            <para>blocking compute operation that does read + compute + write </para>
            </summary>
            <param name="cruncher"></param>
            <param name="computeId"></param>
            <param name="kernelNamesString">string that contains all kernel names(to be executed) separated by space or by , or by ;</param>
            <param name="globalRange">total workitems to be distributed to devices</param>
            <param name="localRange">workitems per local workgroup. default value is 256</param>
            <param name="ofsetGlobalRange">starting id for workitems.(for cluster add-on)</param>
            <param name="pipeline">true: pipeline is on (this is out of OpenCL 1.2 specs so use at your own risk)</param>
            <param name="pipelineType">Cores.PIPELINE_EVENT means event-driven 3-queued pipelined read+compute+write operation. </param>
            <param name="pipelineBlobs">minimum 4, multiple of 4</param>
            <param name="readWritesReady">
            <para>used by ClTask. compute() uses predetermined array fields in this array instead of current values.</para>
            <para>null = current values will be used</para>
            </param>
            <param name="elementsPerItemReady">
            <para>used by ClTask. compute() uses predetermined per-item-elements-value in this array instead of current values.</para>
            <para>null = current values will be used</para>
            </param>
        </member>
        <member name="T:Cekirdekler.ClArrays.ICanBind">
            <summary>
            binds new parameters to earlier ones to be used in kernel executions
            </summary>
        </member>
        <member name="M:Cekirdekler.ClArrays.ICanBind.nextParam(Cekirdekler.ClArrays.ClParameterGroup[])">
            <summary>
            <para>adds arrays as more parameters for kernel execution</para>
            <para>arrays order as parameters:</para>
            <para>this object - then - other params added to this object - then - parameters from .nextParam()</para>
            </summary>
            <param name="parameterGroups_">Other parameter groups to add as kernel parameters</param>
            <returns>a ClParameterGroup that can crunch numbers or bind more parameters</returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ICanBind.nextParam(Cekirdekler.ClArrays.IBufferOptimization[])">
            <summary>
            <para>adds arrays as more parameters for kernel execution</para>
            <para>arrays order as parameters:</para>
            <para>this object - then - other params added to this object - then - parameters from .nextParam()</para>
            </summary>
            <param name="arrays_">ClArray type arrays(which can wrap C# or C++ arrays) to add as kernel parameters</param>
            <returns>a ClParameterGroup that can crunch numbers or bind more parameters</returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ICanBind.nextParam(Cekirdekler.ClArrays.IMemoryHandle[])">
            <summary>
            <para>adds arrays as more parameters for kernel execution</para>
            <para>arrays order as parameters:</para>
            <para>this object - then - other params added to this object - then - parameters from .nextParam()</para>
            </summary>
            <param name="arrays_">FastArr type(ClFloatArray,ClUIntArray,...) arrays to add as kernel parameters</param>
            <returns>a ClParameterGroup that can crunch numbers or bind more parameters</returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ICanBind.nextParam(System.Array[])">
            <summary>
            <para>adds arrays as more parameters for kernel execution</para>
            <para>arrays order as parameters:</para>
            <para>this object - then - other params added to this object - then - parameters from .nextParam()</para>
            </summary>
            <param name="arrays_">C# arrays to add as kernel parameters</param>
            <returns>a ClParameterGroup that can crunch numbers or bind more parameters</returns>
        </member>
        <member name="P:Cekirdekler.ClArrays.ICanBind.array">
            <summary>
            C++ or C# array of current object
            </summary>
        </member>
        <member name="T:Cekirdekler.ClArrays.ClArray`1">
            <summary>
            <para>float,byte,...</para>
            <para>double,long</para>
            <para>int,uint</para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.ToArray">
            <summary>
            gets a copy as C# array
            </summary>
            <returns></returns>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClArray`1.N">
            <summary>
            <para>number of elements of this array(C++ or C# side)</para>
            <para>when set to a different value, a new array is allocated(or created), old data is copied, remaining elements are defaulted</para>
            <para>if new value is smaller, elements at the end of array are lost</para>
            </summary>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.#ctor(System.Int32,System.Int32)">
            <summary>
            <para>Wrapper for C++ and C# arrays, can optimize their copies to devices(or devices' access to them)</para>
            </summary>
            <param name="n_">number of elements(not bytes), default=-1 (no array allocated)</param>
            <param name="a_">alignment value(in bytes), default=4096</param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.dispose">
            <summary>
            release C++ resources, callable multiple times
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClArray`1.isDeleted">
            <summary>
            if C++ resources are released or not
            </summary>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.Finalize">
            <summary>
            release C++ resources
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClArray`1.fastArr">
            <summary>
            <para>if given true, allocates a C++ array(if C# array exists, copies from it)</para>
            <para>if given false, creates a C# array (if C++ array exists, copies from it)</para>
            <para>if array property is set from client code, this is changed accordingly with that array type</para>
            </summary>
        </member>
        <member name="F:Cekirdekler.ClArrays.ClArray`1.array_">
            <summary>
            <para>float[], byte[], FastArr{T} ... </para>
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClArray`1.array">
            <summary>
            C++(FastArr{T}) or C# (T[]) arrays
            </summary>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.op_Implicit(`0[])~Cekirdekler.ClArrays.ClArray{`0}">
            <summary>
            <para>initialize this wrapper from T[] or FastArr{T}</para> 
            </summary>
            <param name="b"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.op_Implicit(Cekirdekler.ClArrays.FastArr{`0})~Cekirdekler.ClArrays.ClArray{`0}">
            <summary>
            <para>initialize this wrapper from T[] or FastArr{T}</para> 
            </summary>
            <param name="b"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.wrapArrayOfStructs(System.Object)">
            <summary>
            <para>since there is not array of struct to generic implicit conversion</para>
            <para>needs this method to generate a byte array wrapper</para>
            <para>pins the wrapped array</para>
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClArray`1.Count">
            <summary>
            IList{T} compatibility, gives number of elements of C# or C++ arrays
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClArray`1.Length">
            <summary>
            IList{T} compatibility, gives number of elements of C# or C++ arrays
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClArray`1.IsReadOnly">
            <summary>
            not implemented
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClArray`1.isCSharpArr">
            <summary>
            true = C# array
            false = C++ array (wrapper)
            </summary>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.IndexOf(`0)">
            <summary>
            not implemented
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.Insert(System.Int32,`0)">
            <summary>
            not implemented
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.RemoveAt(System.Int32)">
            <summary>
            not implemented
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.Add(`0)">
            <summary>
            not implemented
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.Clear">
            <summary>
            not implemented
            </summary>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.Contains(`0)">
            <summary>
            not implemented
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.CopyTo(`0[],System.Int32)">
            <summary>
            copies to C# array (from its C++ or C# array)  
            </summary>
            <param name="array">C# array</param>
            <param name="arrayIndex">element index</param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.CopyTo(Cekirdekler.ClArrays.ClArray{`0},System.Int32)">
            <summary>
            copies to other ClArray objects' arrays
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.CopyTo(Cekirdekler.ClArrays.FastArr{`0},System.Int32)">
            <summary>
            copy to C++ array (FastArr)
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.CopyFrom(`0[],System.Int32)">
            <summary>
            copies from C# array(to C++ or C# array of itself)
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.CopyFrom(Cekirdekler.ClArrays.ClArray{`0},System.Int32)">
            <summary>
            copies from other ClArray objects
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.CopyFrom(Cekirdekler.ClArrays.FastArr{`0},System.Int32)">
            <summary>
            copies from C++ array(to its own C++ or C# array)
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.Remove(`0)">
            <summary>
            not implemented
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.GetEnumerator">
            <summary>
            not implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            not implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.nextParam(System.Array[])">
            <summary>
            <para>adds arrays as more parameters for kernel execution</para>
            <para>arrays order as parameters:</para>
            <para>this object - then - other params added to this object - then - parameters from .nextParam()</para>
            </summary>
            <param name="arrays_">C# arrays to add as kernel parameters</param>
            <returns>a ClParameterGroup that can crunch numbers or bind more parameters</returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.nextParam(Cekirdekler.ClArrays.IMemoryHandle[])">
            <summary>
            <para>adds arrays as more parameters for kernel execution</para>
            <para>arrays order as parameters:</para>
            <para>this object - then - other params added to this object - then - parameters from .nextParam()</para>
            </summary>
            <param name="arrays_">FastArr type(ClFloatArray,ClUIntArray,...) arrays to add as kernel parameters</param>
            <returns>a ClParameterGroup that can crunch numbers or bind more parameters</returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.nextParam(Cekirdekler.ClArrays.IBufferOptimization[])">
            <summary>
            <para>adds arrays as more parameters for kernel execution</para>
            <para>arrays order as parameters:</para>
            <para>this object - then - other params added to this object - then - parameters from .nextParam()</para>
            </summary>
            <param name="arrays_">ClArray type arrays(which can wrap C# or C++ arrays) to add as kernel parameters</param>
            <returns>a ClParameterGroup that can crunch numbers or bind more parameters</returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.nextParam(Cekirdekler.ClArrays.ClParameterGroup[])">
            <summary>
            <para>adds arrays as more parameters for kernel execution</para>
            <para>arrays order as parameters:</para>
            <para>this object - then - other params added to this object - then - parameters from .nextParam()</para>
            </summary>
            <param name="parameterGroups_">Other parameter groups to add as kernel parameters</param>
            <returns>a ClParameterGroup that can crunch numbers or bind more parameters</returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.task(System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            <para>creates task to compute later, meant to be used in pools mainly</para>
            </summary>
            <param name="computeId"></param>
            <param name="kernelNamesString">string that contains all kernel names(to be executed) separated by space or by , or by ;</param>
            <param name="globalRange">total workitems to be distributed to devices</param>
            <param name="localRange">workitems per local workgroup. default value is 256</param>
            <param name="ofsetGlobalRange">starting id for workitems.(for cluster add-on)</param>
            <param name="pipeline">true: pipeline is on</param>
            <param name="pipelineType">Cores.PIPELINE_EVENT means event-driven 3-queued pipelined read+compute+write operation. </param>
            <param name="pipelineBlobs">minimum 4, multiple of 4</param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClArray`1.compute(Cekirdekler.ClNumberCruncher,System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Int32,System.String[],System.Int32[])">
            <summary>
            <para>blocking compute operation that does read + compute + write unless enqueueMode is enabled in number cruncher </para>
            </summary>
            <param name="cruncher"></param>
            <param name="computeId"></param>
            <param name="kernelNamesString">string that contains all kernel names(to be executed) separated by space or by , or by ;</param>
            <param name="globalRange">total workitems to be distributed to devices</param>
            <param name="localRange">workitems per local workgroup. default value is 256</param>
            <param name="ofsetGlobalRange">starting id for workitems.(for cluster add-on)</param>
            <param name="pipeline">true: pipeline is on (this is out of OpenCL 1.2 specs so use at your own risk)</param>
            <param name="pipelineType">Cores.PIPELINE_EVENT means event-driven 3-queued pipelined read+compute+write operation. </param>
            <param name="pipelineBlobs">minimum 4, multiple of 4</param>
            <param name="readWritesReady">
            <para>used by ClTask. compute() uses predetermined array fields in this array instead of current values.</para>
            <para>null = current values will be used</para>
            </param>
            <param name="elementsPerItemReady">
            <para>used by ClTask. compute() uses predetermined per-item-elements-value in this array instead of current values.</para>
            <para>null = current values will be used</para>
            </param>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClArray`1.zeroCopy">
            <summary>
            <para>if the device used in cruncher supports zero copy buffer access, this field determines its usage. true=direct RAM access, false=dedicated memory</para>
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClArray`1.readOnly">
            <summary>
            <para>buffers created in devices will be read by kernel and written by host, always</para>
            <para>prevents usage of write/writeAll/writeOnly, until it is set to false again</para>
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClArray`1.writeOnly">
            <summary>
            <para>buffers created in devices will be written by kernel and read by host, always</para>
            <para>prevents usage of read/partialRead/readOnly, until its set to false again</para>
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClArray`1.read">
            <summary>
            reads whole array before compute (no pipelining)
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClArray`1.partialRead">
            <summary>
            <para>partial reads(possibly pipelined)</para>
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClArray`1.write">
            <summary>
            partial writes (possibly pipelined)
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClArray`1.writeAll">
            <summary>
            whole writes
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClArray`1.numberOfElementsPerWorkItem">
            <summary>
            <para>number of array elements per workitem, default=1</para>
            <para>global range * this number must be smaller than or equal to array size </para>
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClArray`1.arrayLength">
            <summary>
            <para>for more communication between interfaces</para>
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClArray`1.alignmentBytes">
            <summary>
             address alignment in bytes, if contained array is a C++ array
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClArray`1.Item(System.Int32)">
            <summary>
            <para>direct access to C++ array elements just like C# arrays</para>
            <para>don't cross boundaries, don't use after dispose()</para>
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:Cekirdekler.ClArrays.CSpaceArrays">
            <summary>
            C++ "C" space array functions for fast GPGPU
            </summary>
        </member>
        <member name="F:Cekirdekler.ClArrays.CSpaceArrays.ARR_FLOAT">
            <summary>
            32-bit precision floats in C# 
            </summary>
        </member>
        <member name="F:Cekirdekler.ClArrays.CSpaceArrays.ARR_DOUBLE">
            <summary>
            64-bit precision floats in C#
            </summary>
        </member>
        <member name="F:Cekirdekler.ClArrays.CSpaceArrays.ARR_LONG">
            <summary>
            64-bit integer in C#
            </summary>
        </member>
        <member name="F:Cekirdekler.ClArrays.CSpaceArrays.ARR_INT">
            <summary>
            32-bit integer in C#
            </summary>
        </member>
        <member name="F:Cekirdekler.ClArrays.CSpaceArrays.ARR_UINT">
            <summary>
            32-bit unsigned integer in C#
            </summary>
        </member>
        <member name="F:Cekirdekler.ClArrays.CSpaceArrays.ARR_BYTE">
            <summary>
            8bit integer
            </summary>
        </member>
        <member name="F:Cekirdekler.ClArrays.CSpaceArrays.ARR_CHAR">
            <summary>
            2-byte or 16-bit container for integers in C#
            </summary>
        </member>
        <member name="F:Cekirdekler.ClArrays.CSpaceArrays.sizeOf_">
            <summary>
            table of number of bytes per type of element
            </summary>
        </member>
        <member name="M:Cekirdekler.ClArrays.CSpaceArrays.#cctor">
            <summary>
            loading type sizes from "C" space opencl
            </summary>
        </member>
        <member name="M:Cekirdekler.ClArrays.CSpaceArrays.sizeOf(System.Int32)">
            <summary>
            query array element size from table
            </summary>
            <param name="type">example: ARR_BYTE = 5</param>
            <returns>for ARR_BYTE returns 1</returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.CSpaceArrays.sizeOf(System.Int32[])">
            <summary>
            just to get cl_float cl_int sizes from "C" space
            </summary>
            <param name="definitionArr"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.CSpaceArrays.createArray(System.Int32,System.Int32,System.Int32)">
            <summary>
            create "C" space arrays
            </summary>
            <param name="numberOfElements"></param>
            <param name="alignment"></param>
            <param name="typeOfArray"></param>
            <returns>returns pointer to augmented array</returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.CSpaceArrays.alignedArrHead(System.IntPtr)">
            <summary>
            get the first N-aligned element address from "C" space array
            </summary>
            <param name="hArr">handle for "C" space array</param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.CSpaceArrays.deleteArray(System.IntPtr)">
            <summary>
            delete "C" space array
            </summary>
            <param name="hArr">handle for augmented array in "C" space</param>
        </member>
        <member name="M:Cekirdekler.ClArrays.CSpaceArrays.copyMemory(System.IntPtr,System.IntPtr,System.UInt32)">
            <summary>
            IntPtr to IntPtr copy in bytes count
            </summary>
            <param name="dest"></param>
            <param name="src"></param>
            <param name="count">byte number</param>
        </member>
        <member name="T:Cekirdekler.ClArrays.IMemoryOperations`1">
            <summary>
            For copying between C++ and C# arrays
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Cekirdekler.ClArrays.IMemoryOperations`1.CopyFrom(`0[],System.Int32)">
            <summary>
            C# array to C++ array copy
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.IMemoryOperations`1.CopyFrom_(Cekirdekler.ClArrays.FastArr{`0},System.Int32)">
            <summary>
            C++ array to C++ array copy
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.IMemoryOperations`1.CopyTo_(Cekirdekler.ClArrays.FastArr{`0},System.Int32)">
            <summary>
            C++ array to C++ array copy
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="T:Cekirdekler.ClArrays.IMemoryHandle">
            <summary>
            C++ - C# array communication-compatibility interface
            </summary>
        </member>
        <member name="M:Cekirdekler.ClArrays.IMemoryHandle.ha">
            <summary>
            first (4096 default)aligned element address of array
            </summary>
            <returns></returns>
        </member>
        <member name="P:Cekirdekler.ClArrays.IMemoryHandle.Length">
            <summary>
            C++ array's number of elements (for compatibility with C# arrays)
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.IMemoryHandle.sizeOf">
            <summary>
            C++ array element size
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.IMemoryHandle.sizeOfEnum">
            <summary>
            cl_float, cl_int definitions for compatibility with "C" space opencl
            </summary>
        </member>
        <member name="M:Cekirdekler.ClArrays.IMemoryHandle.dispose">
            <summary>
            C++ dizisini siler
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.IMemoryHandle.arrType">
            <summary>
            <para>C++ array type compatible to C# side as</para>
            <para>CSpaceArrays.Arr_FLOAT</para>
            <para>CSpaceArrays.Arr_INT</para>
            <para>CSpaceArrays.Arr_BYTE</para>
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.IMemoryHandle.alignmentBytes">
            <summary>
            address alignment value of the internal shifter array in bytes
            </summary>
        </member>
        <member name="T:Cekirdekler.ClArrays.FastArr`1">
            <summary>
            <para>C++ array in "C" space for fast GPGPU buffer access/map/read/write</para>
            <para>switchabe from C#'s float,double,int,long</para>
            <para>and byte,uint,char</para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Cekirdekler.ClArrays.FastArr`1.hArr">
            <summary>
            C++ array start(non-aligned)
            </summary>
        </member>
        <member name="F:Cekirdekler.ClArrays.FastArr`1.hAArr">
            <summary>
            C++ array first (4096 default)aligned element address
            </summary>
        </member>
        <member name="F:Cekirdekler.ClArrays.FastArr`1.n_">
            <summary>
            number of elements in array
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.FastArr`1.sizeOf">
            <summary> 
            size of each array element
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.FastArr`1.sizeOfEnum">
            <summary>
            ClBuffer connection compatibility variable
            </summary>
        </member>
        <member name="M:Cekirdekler.ClArrays.FastArr`1.#ctor(System.IntPtr,System.Int32)">
            <summary>
            byte array only, for the array of struct support
            </summary>
            <param name="pinnedStructArrayPointer"></param>
            <param name="n"></param>
            <param name="align"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.FastArr`1.Finalize">
            <summary>
            delete C++ "C" space array
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.FastArr`1.Length">
            <summary>
            C++ array's number of elements (just like C# array) 
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.FastArr`1.Item(System.Int32)">
            <summary>
            overriden by derived classes and not be used by client codes for now
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.FastArr`1.ha">
            <summary>
            first properly aligned element of C++ array
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.FastArr`1.dispose">
            <summary>
            deletes C++ array, can be called multiple times
            </summary>
        </member>
        <member name="M:Cekirdekler.ClArrays.FastArr`1.ToArray">
            <summary>
            return a copy of C++ array as a C# array
            </summary>
            <returns></returns>
        </member>
        <member name="P:Cekirdekler.ClArrays.FastArr`1.Count">
            <summary>
            for compatibility with IList{T} 
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.FastArr`1.IsReadOnly">
            <summary>
            not implemented
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.FastArr`1.arrType">
            <summary>
            <para>C++ array type compatible to C# side as</para>
            <para>CSpaceArrays.Arr_FLOAT</para>
            <para>CSpaceArrays.Arr_INT</para>
            <para>CSpaceArrays.Arr_BYTE</para>
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.FastArr`1.alignmentBytes">
            <summary>
            address alignment of internal shifted array in bytes
            </summary>
        </member>
        <member name="M:Cekirdekler.ClArrays.FastArr`1.Add(`0)">
            <summary>
            not implemented
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.FastArr`1.Clear">
            <summary>
            not implemented
            </summary>
        </member>
        <member name="M:Cekirdekler.ClArrays.FastArr`1.Contains(`0)">
            <summary>
            not implemented
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.FastArr`1.CopyTo(`0[],System.Int32)">
            <summary>
            overridden by derived classes
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.FastArr`1.GetEnumerator">
            <summary>
            not implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.FastArr`1.IndexOf(`0)">
            <summary>
            not implemented
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.FastArr`1.Insert(System.Int32,`0)">
            <summary>
            not implemented
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.FastArr`1.Remove(`0)">
            <summary>
            not implemented
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.FastArr`1.RemoveAt(System.Int32)">
            <summary>
            not implemented
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.FastArr`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            not implemented
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.FastArr`1.CopyFrom(`0[],System.Int32)">
            <summary>
            overriden by derived classes
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.FastArr`1.CopyFrom_(Cekirdekler.ClArrays.FastArr{`0},System.Int32)">
            <summary>
            overriden by derived classes
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.FastArr`1.CopyTo_(Cekirdekler.ClArrays.FastArr{`0},System.Int32)">
            <summary>
            overriden by derived classes
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="T:Cekirdekler.ClArrays.ClByteArray">
            <summary>
            C++ byte array
            </summary>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClByteArray.#ctor(System.Int32,System.Int32)">
            <summary>
            allocates a byte array in "C" space for faster opencl computations
            </summary>
            <param name="n"></param>
            <param name="alignment"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClByteArray.#ctor(System.IntPtr,System.Int32,System.Runtime.InteropServices.GCHandle)">
            <summary>
            constructs from IntPtr of GcHandle.Alloc(pinned)
            </summary>
            <param name="pinnedStructArrayPointer"></param>
            <param name="n"></param>
            <param name="handleGC"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClByteArray.Finalize">
            <summary>
            release pinned array
            </summary>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClByteArray.Item(System.Int32)">
            <summary>
            access just like a C# array
            beware! check or be sure for out-of-bounds
            beware! don't use this after dispose()
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClByteArray.ToArray">
            <summary>
            get a copy of fast array as a C# array
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClByteArray.CopyTo(System.Byte[],System.Int32)">
            <summary>
            copy C++ array to C# array
            both must be same length
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClByteArray.CopyFrom(System.Byte[],System.Int32)">
            <summary>
            copy C# array to C++ array
            both must be same length
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClByteArray.CopyTo_(Cekirdekler.ClArrays.FastArr{System.Byte},System.Int32)">
            <summary>
            copy C++ array to C++ array
            both must be same length
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClByteArray.CopyFrom_(Cekirdekler.ClArrays.FastArr{System.Byte},System.Int32)">
            <summary>
            copy C++ array to C++ array
            both must be same length
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="T:Cekirdekler.ClArrays.ClFloatArray">
            <summary>
            C++ float array
            </summary>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClFloatArray.#ctor(System.Int32,System.Int32)">
            <summary>
            C++ float array
            </summary>
            <param name="n">number of elements</param>
            <param name="alignment">byte alignment value</param>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClFloatArray.Item(System.Int32)">
            <summary>
            array indexing similar to C# arrays
            beware, don't cross bounds
            beware, don't use after dispose()
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClFloatArray.ToArray">
            <summary>
            get a copy of C++ array as a C# array 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClFloatArray.CopyTo(System.Single[],System.Int32)">
            <summary>
            copy C++ float array to C# float array
            </summary>
            <param name="array">C# float array</param>
            <param name="arrayIndex">copy start index</param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClFloatArray.CopyFrom(System.Single[],System.Int32)">
            <summary>
            copy C# float array to C++ float array
            </summary>
            <param name="array">C# array</param>
            <param name="arrayIndex">copy start index</param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClFloatArray.CopyTo_(Cekirdekler.ClArrays.FastArr{System.Single},System.Int32)">
            <summary>
            C++ array to C++ array copy, both must be same length
            </summary>
            <param name="array">C++ float array</param>
            <param name="arrayIndex">copy start index</param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClFloatArray.CopyFrom_(Cekirdekler.ClArrays.FastArr{System.Single},System.Int32)">
            <summary>
            C++ to C++ array copy, both must be same length
            </summary>
            <param name="array">C++ float array</param>
            <param name="arrayIndex">copy start index</param>
        </member>
        <member name="T:Cekirdekler.ClArrays.ClIntArray">
            <summary>
            C++ int array
            </summary>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClIntArray.#ctor(System.Int32,System.Int32)">
            <summary>
            C++ int array
            </summary>
            <param name="n"></param>
            <param name="alignment"></param>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClIntArray.Item(System.Int32)">
            <summary>
            access like a C# array, beware: don't cross boundaries and don't use after dispose()
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClIntArray.ToArray">
            <summary>
            get a copy of C++ int array as C# array
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClIntArray.CopyTo(System.Int32[],System.Int32)">
            <summary>
            copy from C++ int array to C# int array, must be same length
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClIntArray.CopyFrom(System.Int32[],System.Int32)">
            <summary>
            copy from C# int array to C++ int array, must be same length
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClIntArray.CopyTo_(Cekirdekler.ClArrays.FastArr{System.Int32},System.Int32)">
            <summary>
            copy from C++ int array to C++ int array, must be same length
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClIntArray.CopyFrom_(Cekirdekler.ClArrays.FastArr{System.Int32},System.Int32)">
            <summary>
            copy from C++ int array to C++ int array, must be same length
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="T:Cekirdekler.ClArrays.ClDoubleArray">
            <summary>
            C++ double array
            </summary>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClDoubleArray.#ctor(System.Int32,System.Int32)">
            <summary>
            C++ double array
            </summary>
            <param name="n"></param>
            <param name="alignment"></param>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClDoubleArray.Item(System.Int32)">
            <summary>
            access like a C# array, don't cross boundaries, don't use after dispose()
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClDoubleArray.ToArray">
            <summary>
            get a copy of C++ array as a C# array
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClDoubleArray.CopyTo(System.Double[],System.Int32)">
            <summary>
            Copy from C++ array to C# array, must be same length
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClDoubleArray.CopyFrom(System.Double[],System.Int32)">
            <summary>
            Copy from C# array to C++ array, must be same length
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClDoubleArray.CopyTo_(Cekirdekler.ClArrays.FastArr{System.Double},System.Int32)">
            <summary>
            Copy from C++ array to C++ array, must be same length
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClDoubleArray.CopyFrom_(Cekirdekler.ClArrays.FastArr{System.Double},System.Int32)">
            <summary>
            Copy from C++ array to C++ array, must be same length
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="T:Cekirdekler.ClArrays.ClCharArray">
            <summary>
            C++ (C#-char) array
            </summary>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClCharArray.#ctor(System.Int32,System.Int32)">
            <summary>
            C++ (C#-char) array
            </summary>
            <param name="n"></param>
            <param name="alignment"></param>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClCharArray.Item(System.Int32)">
            <summary>
            access like a C# array, don't cross boundaries, don't use after dispose()
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClCharArray.ToArray">
            <summary>
            get a copy of C++ arrays as a C# array
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClCharArray.CopyTo(System.Char[],System.Int32)">
            <summary>
            copy C++ array to C# array
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClCharArray.CopyFrom(System.Char[],System.Int32)">
            <summary>
            copy C# array to C++ array
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClCharArray.CopyTo_(Cekirdekler.ClArrays.FastArr{System.Char},System.Int32)">
            <summary>
            copy C++ array to C++ array, must be same length
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClCharArray.CopyFrom_(Cekirdekler.ClArrays.FastArr{System.Char},System.Int32)">
            <summary>
            copy C++ array to C++ array, must be same length
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="T:Cekirdekler.ClArrays.ClLongArray">
            <summary>
            C++ long array
            </summary>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClLongArray.#ctor(System.Int32,System.Int32)">
            <summary>
            C++ long array
            </summary>
            <param name="n"></param>
            <param name="alignment"></param>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClLongArray.Item(System.Int32)">
            <summary>
            access like a C# array, don't cross boundaries, don't use after dispose()
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClLongArray.ToArray">
            <summary>
            get a copy of C++ array as a C# array
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClLongArray.CopyTo(System.Int64[],System.Int32)">
            <summary>
            copy C++ array to C# array, must be same length
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClLongArray.CopyFrom(System.Int64[],System.Int32)">
            <summary>
            copy C# array to C++ array, must be same length
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClLongArray.CopyTo_(Cekirdekler.ClArrays.FastArr{System.Int64},System.Int32)">
            <summary>
            copy C++ array to C++ array, must be same length
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClLongArray.CopyFrom_(Cekirdekler.ClArrays.FastArr{System.Int64},System.Int32)">
            <summary>
            copy from C++ array to C++ array, must be same length
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="T:Cekirdekler.ClArrays.ClUIntArray">
            <summary>
            C++ (C#-uint) array
            </summary>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClUIntArray.#ctor(System.Int32,System.Int32)">
            <summary>
            C++ (C#-uint) array
            </summary>
            <param name="n"></param>
            <param name="alignment"></param>
        </member>
        <member name="P:Cekirdekler.ClArrays.ClUIntArray.Item(System.Int32)">
            <summary>
            access like a C# array, don't cross boundaries, don't use after dispose()
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClUIntArray.ToArray">
            <summary>
            get a copy of C++ array as a C# array
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClUIntArray.CopyTo(System.UInt32[],System.Int32)">
            <summary>
            copy from C++ array to C# array, both must be same size
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClUIntArray.CopyFrom(System.UInt32[],System.Int32)">
            <summary>
            copy from C# array to C++ array, must be same size
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClUIntArray.CopyTo_(Cekirdekler.ClArrays.FastArr{System.UInt32},System.Int32)">
            <summary>
            copy from C++ array to C++ array, must be same size
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Cekirdekler.ClArrays.ClUIntArray.CopyFrom_(Cekirdekler.ClArrays.FastArr{System.UInt32},System.Int32)">
            <summary>
            copy from C++ array to C++ array, must be same size
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="T:Cekirdekler.Hardware.IDeviceQueryable">
            <summary>
            for selecting a subset from hardware
            </summary>
        </member>
        <member name="M:Cekirdekler.Hardware.IDeviceQueryable.cpus(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            select  all gpus from container
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.IDeviceQueryable.gpus(System.Boolean)">
            <summary>
            select gpus
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.IDeviceQueryable.accelerators(System.Boolean)">
            <summary>
            select accelerators
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.IDeviceQueryable.devicesWithMostComputeUnits(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            orders devices with most numerous compute units first, least ones last 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.IDeviceQueryable.devicesWithDedicatedMemory(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            disrete GPUs, fpgas, ...
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.IDeviceQueryable.devicesWithHostMemorySharing(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            iGPUs but not CPUs
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.IDeviceQueryable.devicesWithHighestMemoryAvailable(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            16GB CPU > 8GB GPU
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.IDeviceQueryable.devicesAmd(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Amd devices
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.IDeviceQueryable.devicesNvidia(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Nvidia devices
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.IDeviceQueryable.devicesIntel(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Intel devices
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.IDeviceQueryable.devicesAltera(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Altera devices
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.IDeviceQueryable.devicesXilinx(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Xilinx devices
            </summary>
            <returns></returns>
        </member>
        <member name="T:Cekirdekler.Hardware.IPlatformQueryable">
            <summary>
            select subset of platforms
            </summary>
        </member>
        <member name="M:Cekirdekler.Hardware.IPlatformQueryable.platformsWithMostDevices">
            <summary>
            2 GPU platform > 1 accelerator platform
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.IPlatformQueryable.platformsIntel">
            <summary>
            platforms with a description string containing "Intel" 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.IPlatformQueryable.platformsAmd">
            <summary>
            Amd platforms
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.IPlatformQueryable.platformsNvidia">
            <summary>
            Nvidia platforms
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.IPlatformQueryable.platformsAltera">
            <summary>
            Altera platforms
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.IPlatformQueryable.platformsXilinx">
            <summary>
            Xilinx platforms
            </summary>
            <returns></returns>
        </member>
        <member name="T:Cekirdekler.Hardware.ClPlatforms">
            <summary>
            contains all platforms, overloads [] operator, indexing
            </summary>
        </member>
        <member name="M:Cekirdekler.Hardware.ClPlatforms.platformVendorNames">
            <summary>
            gets platform and vendor names separately
            {platform1,platform2,....}
            platform1: {platformName,vendorName}
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClPlatforms.Finalize">
            <summary>
            disposes all platforms
            </summary>
        </member>
        <member name="M:Cekirdekler.Hardware.ClPlatforms.all">
            <summary>
            get list of all platforms
            </summary>
            <returns></returns>
        </member>
        <member name="P:Cekirdekler.Hardware.ClPlatforms.Item(System.Int32)">
            <summary>
            get 1 platform
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:Cekirdekler.Hardware.ClPlatforms.Length">
            <summary>
            returns number of selected platforms
            </summary>
        </member>
        <member name="M:Cekirdekler.Hardware.ClPlatforms.platformsWithMostDevices">
            <summary>
            gets a copy of platforms tat are sorted on their number of devices
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClPlatforms.platformsIntel">
            <summary>
            gets platforms that have "Intel" in vendor or platform name string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClPlatforms.platformsAmd">
            <summary>
            gets platforms that have "Amd" or "Advanced Micro Devices" in vendor or platform name string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClPlatforms.platformsNvidia">
            <summary>
            gets platforms that have "Nvidia" in vendor or platform name string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClPlatforms.platformsAltera">
            <summary>
            gets platforms that have "Altera" in vendor or platform name string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClPlatforms.platformsXilinx">
            <summary>
            gets platforms that have "Xilinx" in vendor or platform name string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClPlatforms.cpus(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            get all cpu devices from selected platforms
            </summary>
            <param name="devicePartitionEnabled">cpus can be generally partitioned for smaller workloads or data locality</param>
            <param name="streamingEnabled">streaming makes device access to RAM with a zero-copy way if C++ wrapper array is given</param>
            <param name="MAX_CPU_CORES">limit number of cpu cores if device partition is enabled</param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClPlatforms.gpus(System.Boolean)">
            <summary>
            get all gpus from selected platforms
            </summary>
            <param name="streamingEnabled">access to RAM with a zero-copy way when C++ wrapper array is given</param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClPlatforms.accelerators(System.Boolean)">
            <summary>
            selects all accelerators from platforms inside
            </summary>
            <param name="streamingEnabled">access to RAM with zero-copy buffers when C++ array wrapper is given</param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClPlatforms.devicesWithMostComputeUnits(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            get devices ordered by decreasing number of compute units
            </summary>
            <param name="devicePartitionEnabled">for each CPU device, this enables or disables device partition</param>
            <param name="streamingEnabled">for each device, enables zero-copy buffer access for C++ array wrapper parameters</param>
            <param name="MAX_CPU_CORES">for each CPU device with device partitioning enabled, limits max number of cores for the sub-device created</param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClPlatforms.devicesWithDedicatedMemory(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            get devices that don't share RAM with CPU
            </summary>
            <param name="devicePartitionEnabled">for each CPU device, this enables or disables device partition</param>
            <param name="streamingEnabled">for each device, enables zero-copy buffer access for C++ array wrapper parameters</param>
            <param name="MAX_CPU_CORES">for each CPU device with device partitioning enabled, limits max number of cores for the sub-device created</param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClPlatforms.devicesWithHostMemorySharing(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            get devices that share RAM with CPU
            </summary>
            <param name="devicePartitionEnabled">for each CPU device, this enables or disables device partition</param>
            <param name="streamingEnabled">for each device, enables zero-copy buffer access for C++ array wrapper parameters</param>
            <param name="MAX_CPU_CORES">for each CPU device with device partitioning enabled, limits max number of cores for the sub-device created</param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClPlatforms.devicesWithHighestMemoryAvailable(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            sort devices by memory size in descending order
            </summary>
            <param name="devicePartitionEnabled"></param>
            <param name="streamingEnabled"></param>
            <param name="MAX_CPU_CORES"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClPlatforms.devicesAmd(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            get devices with Amd or Advanced Micro Devices in name or vendor name
            </summary>
            <param name="devicePartitionEnabled"></param>
            <param name="streamingEnabled"></param>
            <param name="MAX_CPU_CORES"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClPlatforms.devicesNvidia(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            get devices with Nvidia or Gtx or Titan in name or vendor name
            </summary>
            <param name="devicePartitionEnabled"></param>
            <param name="streamingEnabled"></param>
            <param name="MAX_CPU_CORES"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClPlatforms.devicesIntel(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            get devices with Intel in name or vendor name
            </summary>
            <param name="devicePartitionEnabled"></param>
            <param name="streamingEnabled"></param>
            <param name="MAX_CPU_CORES"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClPlatforms.devicesAltera(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            get devices with Altera in name or vendor name
            </summary>
            <param name="devicePartitionEnabled"></param>
            <param name="streamingEnabled"></param>
            <param name="MAX_CPU_CORES"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClPlatforms.devicesXilinx(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            get devices with Xilinx in name or vendor name 
            </summary>
            <param name="devicePartitionEnabled"></param>
            <param name="streamingEnabled"></param>
            <param name="MAX_CPU_CORES"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClPlatforms.logInfo">
            <summary>
            info about platform details
            </summary>
        </member>
        <member name="T:Cekirdekler.Hardware.ClDevices">
            <summary>
            has devices of a selected platform or all platforms, overloads [] indexing to pick one by one
            </summary>
        </member>
        <member name="P:Cekirdekler.Hardware.ClDevices.Item(System.Int32)">
            <summary>
            get 1 device
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClDevices.#ctor">
            <summary>
            must start from platforms.all() then narrow the selection until it reaches device
            </summary>
        </member>
        <member name="M:Cekirdekler.Hardware.ClDevices.op_Addition(Cekirdekler.Hardware.ClDevices,Cekirdekler.Hardware.ClDevices)">
            <summary>
            add two groups of devices into one
            </summary>
            <param name="d1"></param>
            <param name="d2"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClDevices.copyExact(System.Int32[])">
            <summary>
            copies devices with same parameters
            </summary>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="P:Cekirdekler.Hardware.ClDevices.Length">
            <summary>
            returns number of selected devices 
            </summary>
        </member>
        <member name="M:Cekirdekler.Hardware.ClDevices.logInfo">
            <summary>
            device details
            </summary>
        </member>
        <member name="M:Cekirdekler.Hardware.ClDevices.accelerators(System.Boolean)">
            <summary>
            get all accelerators(such as fpgas) from list
            </summary>
            <param name="streamingEnabled"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClDevices.cpus(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            get all cpus from list
            </summary>
            <param name="devicePartitionEnabled"></param>
            <param name="streamingEnabled"></param>
            <param name="MAX_CPU_CORES"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClDevices.gpus(System.Boolean)">
            <summary>
            get all gpus from list
            </summary>
            <param name="streamingEnabled"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClDevices.devicesAltera(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            selects devices with Altera in name or vendor name
            </summary>
            <param name="devicePartitionEnabled"></param>
            <param name="streamingEnabled"></param>
            <param name="MAX_CPU_CORES"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClDevices.devicesAmd(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            selects devices with Amd in name or vendor name
            </summary>
            <param name="devicePartitionEnabled"></param>
            <param name="streamingEnabled"></param>
            <param name="MAX_CPU_CORES"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClDevices.devicesIntel(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            get devices with Intel in name or vendor name
            </summary>
            <param name="devicePartitionEnabled"></param>
            <param name="streamingEnabled"></param>
            <param name="MAX_CPU_CORES"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClDevices.devicesNvidia(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            get devices with Nvidia(or gtx or titan) in device name or device vendor name
            </summary>
            <param name="devicePartitionEnabled"></param>
            <param name="streamingEnabled"></param>
            <param name="MAX_CPU_CORES"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClDevices.devicesXilinx(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            get devices with Xilinx in device name or device vendor name
            </summary>
            <param name="devicePartitionEnabled"></param>
            <param name="streamingEnabled"></param>
            <param name="MAX_CPU_CORES"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClDevices.devicesWithDedicatedMemory(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            devices with dedicated memory such as discrete graphics cards
            </summary>
            <param name="devicePartitionEnabled"></param>
            <param name="streamingEnabled"></param>
            <param name="MAX_CPU_CORES"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClDevices.devicesWithHighestMemoryAvailable(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            reorders devices from highest to lowest memory
            </summary>
            <param name="devicePartitionEnabled"></param>
            <param name="streamingEnabled"></param>
            <param name="MAX_CPU_CORES"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClDevices.devicesWithHostMemorySharing(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            generally iGPUs fall into this category
            </summary>
            <param name="devicePartitionEnabled"></param>
            <param name="streamingEnabled"></param>
            <param name="MAX_CPU_CORES"></param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClDevices.devicesWithMostComputeUnits(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            get devices ordered by decreasing number of compute units
            </summary>
            <param name="devicePartitionEnabled">for each CPU device, this enables or disables device partition</param>
            <param name="streamingEnabled">for each device, enables zero-copy buffer access for C++ array wrapper parameters</param>
            <param name="MAX_CPU_CORES">for each CPU device with device partitioning enabled, limits max number of cores for the sub-device created</param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClDevices.devicesWithHighestDirectNbodyPerformance(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            get devices ordered by decreasing number of compute units
            </summary>
            <param name="devicePartitionEnabled">for each CPU device, this enables or disables device partition</param>
            <param name="streamingEnabled">for each device, enables zero-copy buffer access for C++ array wrapper parameters</param>
            <param name="MAX_CPU_CORES">for each CPU device with device partitioning enabled, limits max number of cores for the sub-device created</param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClDevices.devicesWithHighestIntrapolatedNbodyPerformance(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            <para>not implemented(yet)</para>
            <para>intrapolated version of devicesWithHighestDirectNbodyPerformance()</para>
            </summary>
            <param name="devicePartitionEnabled">for each CPU device, this enables or disables device partition</param>
            <param name="streamingEnabled">for each device, enables zero-copy buffer access for C++ array wrapper parameters</param>
            <param name="MAX_CPU_CORES">for each CPU device with device partitioning enabled, limits max number of cores for the sub-device created</param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Hardware.ClDevices.devicesWithHighestLeastOscillatedNbodyPerformance(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            <para>not implemented(yet)</para>
            <para>intrapolated version of devicesWithHighestDirectNbodyPerformance()</para>
            </summary>
            <param name="devicePartitionEnabled">for each CPU device, this enables or disables device partition</param>
            <param name="streamingEnabled">for each device, enables zero-copy buffer access for C++ array wrapper parameters</param>
            <param name="MAX_CPU_CORES">for each CPU device with device partitioning enabled, limits max number of cores for the sub-device created</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Cekirdekler.License" -->
        <!-- Badly formed XML comment ignored for member "M:Cekirdekler.License.readMe" -->
        <member name="T:Cekirdekler.Tester">
            <summary>
            for testing all features in different PCs 
            </summary>
        </member>
        <member name="M:Cekirdekler.Tester.byteArrayOperations">
            <summary>
            tests byte arrays
            </summary>
            <returns>1=error,0=ok</returns>
        </member>
        <member name="M:Cekirdekler.Tester.charArrayOperations">
            <summary>
            tests (C# char) arrays
            </summary>
            <returns>1=error,0=ok</returns>
        </member>
        <member name="M:Cekirdekler.Tester.intArrayOperations">
            <summary>
            tests int arrays
            </summary>
            <returns>1=error,0=ok</returns>
        </member>
        <member name="M:Cekirdekler.Tester.uintArrayOperations">
            <summary>
            tests uint arrays
            </summary>
            <returns>1=error,0=ok</returns>
        </member>
        <member name="M:Cekirdekler.Tester.floatArrayOperations">
            <summary>
            tests float arrays
            </summary>
            <returns>1=error,0=ok</returns>
        </member>
        <member name="M:Cekirdekler.Tester.doubleArrayOperations">
            <summary>
            tests double arrays
            </summary>
            <returns>1=error,0=ok</returns>
        </member>
        <member name="M:Cekirdekler.Tester.longArrayOperations">
            <summary>
            tests long arrays
            </summary>
            <returns>1=error,0=ok</returns>
        </member>
        <member name="M:Cekirdekler.Tester.buffers">
            <summary>
            tests host side buffer operations
            </summary>
        </member>
        <member name="M:Cekirdekler.Tester.nBody(System.Int32,Cekirdekler.Hardware.ClDevices,System.Boolean,System.Boolean)">
            <summary>
            compares an nbody all-pairs(bruteforce) implementation for a C# vs opencl (2D-forces within (+/-)0.01f)
            </summary>
            <param name="n">optional number of particles</param>
            <param name="benchDevices">optional benchmark devices</param>
            <param name="streamEnabled">use devices as streaming processors or with dedicated memories</param>
            <param name="consoleLog">logs intermediate benchmark information to console</param>
            <returns></returns>
        </member>
        <member name="M:Cekirdekler.Tester.stream_C_equals_A_plus_B_1M_elements(System.Int32)">
            <summary>
            pipelined + streamed data performance test.
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="T:ClCluster.ClCruncherClient">
            <summary>
            prealpha cluster feature
            </summary>
        </member>
        <member name="T:ClCluster.ClCruncherServer">
            <summary>
            prealpha cluster feature
            </summary>
        </member>
        <member name="T:ClCluster.ClCruncherServerThread">
            <summary>
            prealpha cluster feature
            </summary>
        </member>
        <member name="T:ClCluster.ClusterAccelerator">
            <summary>
            <para>prealpha cluster add-on</para>
            <para>"cluster:xxxxx" then this class is used</para> 
            <para>todo: make this tree-like structure to enable grid computing or multi level cluster</para>
            </summary>
        </member>
        <member name="M:ClCluster.ClusterAccelerator.findServer(System.Int32,System.Boolean)">
            <summary>
            checks client with given port parameters (example:  50000 ports of all servers)
            </summary>
        </member>
        <member name="T:ClCluster.IComputeNode">
            <summary>
            <para>prealpha cluster add-on</para>
            <para>hesaplayacak nesne, Cekirdekler api de olabilir,</para> 
            <para>bir pc(ip tcp) grubunda çalışan Hizlandirici api de(içinde Cekirdekler var) olabilir</para> 
            </summary>
        </member>
        <member name="M:ClCluster.IComputeNode.compute(System.String[],System.Int32,System.String,System.Object[],System.String[],System.Int32[],System.Int32,System.Int32,System.Int32,System.Boolean,System.Int32,System.Boolean)">
            <summary>
            compute
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClCluster.IComputeNode.computeTiming">
            <summary>
            total time for read compute write
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClCluster.IComputeNode.dispose">
            <summary>
            release C++ resources
            </summary>
        </member>
        <member name="T:ClCluster.NetworkBuffer">
            <summary>
            prealpha cluster add-on
            </summary>
        </member>
        <member name="M:ClCluster.NetworkBuffer.oku(System.Byte[],System.String,System.Object[])">
            <summary>
            gelen buffer bilgisinden Dictionary üretir, dizileri sırasıyla list halinde döndürür
            </summary>
        </member>
        <member name="T:ClCluster.ClusterLoadBalancer">
            <summary>
            prealpha cluster add-on
            </summary>
        </member>
        <member name="M:ClCluster.ClusterLoadBalancer.#ctor">
            <summary>
            her çalışma adımında önceki adımdaki aygıt performanslarına göre aygıtların yeni
            yüklerini belirler.
            Sonradan yeni aygıt eklenebilir
            </summary>
            <param name="toplamMenzil">dengelenecek yükün tamamı</param>
            <param name="enKucukParcalar">her aygıt için ayrı olarak,
            dengeleme için eklenebilecek veya çıkartılabilecek en küçük yük miktarı
            Bu değer, aygıttaki(bilgisayardaki) ekran kartı + işlemci sayısının,
            opencl-local-thread sayıları ve pipeline parça sayıları ile çarpımlarının toplamlarına eşittir
            Bir bilgisayarda 3 ekran kartı varsa ve her biri 256 local thread sayısına sahipse
            o bilgisayarın en küçük yük adımı 768 thread olur. Pipeline optimizasyonu kullanılmışsa ve
            pipeline adımı sayısı 16 ise, en küçük yük adımı 768 * 16 yani 12288 thread olur.
            Bu şekilde tüm bilgisayarların mutlaka toplam thread sayısı kadar thread paylaşabilmeleri zorunludur
            En küçük adımları 512 olan iki bilgisayara toplam 1280 thread paylaştırılamaz.
            Veya 256 fazladan thread kullanılır ama kernel içinde bunlar kullanılmaz(verimsiz de olsa çalışmış olur)</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ClCluster.ClusterLoadBalancer.balanceOnPerformances(System.Double[],System.Int32,System.Int32[],System.Int32[],System.Int32,System.Double)" -->
        <member name="T:ClObject.ClBuffer">
            <summary>
            wrapper for cl::buffer and read-write-map-unmap functions
            </summary>
        </member>
        <member name="T:ClObject.ClBuffer.SizeOf">
            <summary>
            opencl buffer type, duplicated for CSpaceArrays for "internal" optimization
            </summary>
        </member>
        <member name="M:ClObject.ClBuffer.#ctor(ClObject.ClContext,System.Int32,ClObject.ClBuffer.SizeOf,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.IntPtr)">
            <summary>
            create opencl buffer 
            </summary>
            <param name="context"></param>
            <param name="numberOfElements_"></param>
            <param name="clType_"></param>
            <param name="GDDR_BUFFER"></param>
            <param name="isCSharpArray_"></param>
            <param name="arrPointer"></param>
            <param name="readOnly">always kernel reads, host writes</param>
            <param name="writeOnly">always kernel writes, host reads</param>
        </member>
        <member name="M:ClObject.ClBuffer.h">
            <summary>
            handle to buffer object 
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClBuffer.write(ClObject.ClCommandQueue,System.Object)">
            <summary>
            write to buffer from array
            </summary>
            <param name="cq">command queue to enqueue this write command</param>
            <param name="arr">array to read (to write on buffer)</param>
        </member>
        <member name="M:ClObject.ClBuffer.read(ClObject.ClCommandQueue,System.Object)">
            <summary>
            read from buffer to array
            </summary>
            <param name="cq">command queue to enqueue this read command</param>
            <param name="arr">array to write (to read on buffer)</param>
        </member>
        <member name="M:ClObject.ClBuffer.writeRanged(ClObject.ClCommandQueue,System.Int32,System.Int32,System.Object)">
            <summary>
            write to buffer from array but with constraints
            </summary>
            <param name="cq"></param>
            <param name="reference"></param>
            <param name="range"></param>
            <param name="arr"></param>
        </member>
        <member name="M:ClObject.ClBuffer.writeRangedEvent(ClObject.ClCommandQueue,System.Int32,System.Int32,System.Object,ClObject.ClEventArray,ClObject.ClEvent)">
            <summary>
            write to buffer from array but with constraints and events
            </summary>
            <param name="cq"></param>
            <param name="reference"></param>
            <param name="range"></param>
            <param name="arr"></param>
            <param name="eArr"></param>
            <param name="e"></param>
        </member>
        <member name="M:ClObject.ClBuffer.read(ClObject.ClCommandQueue,System.Int32,System.Int32,System.Object)">
            <summary>
            read from buffer and write to array
            </summary>
            <param name="cq"></param>
            <param name="reference"></param>
            <param name="range"></param>
            <param name="arr"></param>
        </member>
        <member name="M:ClObject.ClBuffer.readEvent(ClObject.ClCommandQueue,System.Int32,System.Int32,System.Object,ClObject.ClEventArray,ClObject.ClEvent)">
            <summary>
            read from buffer and write to array but with events
            </summary>
            <param name="cq"></param>
            <param name="reference"></param>
            <param name="range"></param>
            <param name="arr"></param>
            <param name="eArr"></param>
            <param name="e"></param>
        </member>
        <member name="M:ClObject.ClBuffer.dispose">
            <summary>
            release C++ resources
            </summary>
        </member>
        <member name="T:ClObject.ClCommandQueue">
            <summary>
            wrapper for opencl command queue
            </summary>
        </member>
        <member name="M:ClObject.ClCommandQueue.#ctor(ClObject.ClContext,System.Boolean,System.Int32)">
            <summary>
            creates a command queue in a context
            </summary>
            <param name="context"></param>
            <param name="defaultQueue">OpenCL 2.0 dynamic parallelism queue</param>
            <param name="async">async!=0 means out-of-order command queue</param>
        </member>
        <member name="M:ClObject.ClCommandQueue.h">
            <summary>
            handle to command queue object in C++
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClCommandQueue.hc">
            <summary>
            handle to context object in C++ which holds this command queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClCommandQueue.hd">
            <summary>
            handle to device in C++ which is used for this command queue
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClCommandQueue.dispose">
            <summary>
            releases C++ resources for this commmand queue
            </summary>
        </member>
        <member name="T:ClObject.ClContext">
            <summary>
            wrapper for opencl context
            </summary>
        </member>
        <member name="M:ClObject.ClContext.#ctor(ClObject.ClDevice)">
            <summary>
            creates a context for a device, this library makes use of explicit multi device control for compute
            </summary>
            <param name="device">device to use for context</param>
        </member>
        <member name="M:ClObject.ClContext.h">
            <summary>
            handle to context object in C++
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClContext.hd">
            <summary>
            handle to device object in C++ which is used in this context
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClContext.hp">
            <summary>
            handle to platform object in C++ which holds the device for this context
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClContext.dispose">
            <summary>
            release C++ resources
            </summary>
        </member>
        <member name="T:ClObject.ClDevice">
            <summary>
            wrapper for opencl device objects
            </summary>
        </member>
        <member name="M:ClObject.ClDevice.copyWithPlatformCopy(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            copies platform too, to stop different ClNumberCruncher instances destroying their common platform
            </summary>
            <param name="devicePartitionEnabled"></param>
            <param name="streamingEnabled"></param>
            <param name="MAX_CPU_CORES"></param>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClDevice.isGddr">
            <summary>
            if device has dedicated memory, returns true
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClDevice.type">
            <summary>
            type of device
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClDevice.name">
            <summary>
            device name
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClDevice.vendorName">
            <summary>
            device vendor name
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClDevice.h">
            <summary>
            handle for device object in C space
            </summary>
            <returns>address</returns>
        </member>
        <member name="M:ClObject.ClDevice.hp">
            <summary>
            handle for platform object (that contains this device object) in C space
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClDevice.cruncherWillDispose">
            <summary>
            this device and its platform is used in number crunching and will be disposed in there
            </summary>
        </member>
        <member name="M:ClObject.ClDevice.dispose">
            <summary>
            releases resources taken in C++ C space functions
            </summary>
        </member>
        <member name="M:ClObject.ClDevice.Finalize">
            <summary>
            releases C++ resources when not needed (and not referenced)
            </summary>
        </member>
        <member name="T:ClObject.ClEvent">
            <summary>
            wrapper for opencl event objects
            </summary>
        </member>
        <member name="M:ClObject.ClEvent.#ctor">
            <summary>
            creates an event to be used in commands
            </summary>
        </member>
        <member name="M:ClObject.ClEvent.h">
            <summary>
            handle to event object
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClEvent.dispose">
            <summary>
            releases C++ resources
            </summary>
        </member>
        <member name="T:ClObject.ClEventArray">
            <summary>
            wrapper for event array in C++
            </summary>
        </member>
        <member name="M:ClObject.ClEventArray.#ctor(System.Boolean)">
            <summary>
            creates event array for opencl commands
            </summary>
            <param name="isCopy"></param>
        </member>
        <member name="M:ClObject.ClEventArray.add(ClObject.ClEvent,System.Boolean)">
            <summary>
            adds event to event array
            </summary>
            <param name="e"></param>
            <param name="isCopy"></param>
        </member>
        <member name="M:ClObject.ClEventArray.h">
            <summary>
            handle to event array object
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClEventArray.dispose">
            <summary>
            releases C++ resources
            </summary>
        </member>
        <member name="T:ClObject.ClKernel">
            <summary>
            wrapper for opencl kernel object
            </summary>
        </member>
        <member name="M:ClObject.ClKernel.#ctor(ClObject.ClProgram,ClObject.ClString)">
            <summary>
            takes program and a kernel name and prepares a kernel to be used.
            </summary>
            <param name="program">opencl wrapper of cl::program</param>
            <param name="kernelName">string wrapper of kernel name</param>
        </member>
        <member name="M:ClObject.ClKernel.h">
            <summary>
            handle for kernel object in "C" space
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClKernel.hs">
            <summary>
            kernel name string pointer
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClKernel.dispose">
            <summary>
            releases resources that are allocated in "C" space
            </summary>
        </member>
        <member name="T:ClObject.ClNdRange">
            <summary>
            wrapper for opencl ndrange
            </summary>
        </member>
        <member name="M:ClObject.ClNdRange.#ctor(System.Int32)">
            <summary>
            creates a ndrange object in "C" space
            </summary>
            <param name="range_"></param>
        </member>
        <member name="M:ClObject.ClNdRange.h">
            <summary>
            handle to ndrange object in C++
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClNdRange.dispose">
            <summary>
            release C++ resources
            </summary>
        </member>
        <member name="T:ClObject.ClPlatform">
            <summary>
            cl::platform wrapper with simple methods
            </summary>
        </member>
        <member name="M:ClObject.ClPlatform.CODE_CPU">
            <summary>
            takes cpu flag to be used later in other wrappers
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClPlatform.CODE_GPU">
            <summary>
            takes gpu flag to be used later in other wrappers
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClPlatform.CODE_ACC">
            <summary>
            takes accelerator flag to be used in other wrappers
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClPlatform.numberOfCpusInPlatform(System.IntPtr)">
            <summary>
            number of cpus in a platform
            </summary>
            <param name="hPlatform"></param>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClPlatform.numberOfGpusInPlatform(System.IntPtr)">
            <summary>
            number of gpus in a platform
            </summary>
            <param name="hPlatform"></param>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClPlatform.numberOfAcceleratorsInPlatform(System.IntPtr)">
            <summary>
            number of accelerators in platorm
            </summary>
            <param name="hPlatform"></param>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClPlatform.#ctor(System.IntPtr,System.Int32)">
            <summary>
            gets a platform from a list of platforms in "C" space using an index
            </summary>
            <param name="hPlatformList_">C space array with N platforms</param>
            <param name="index_">0 to N-1</param>
        </member>
        <member name="M:ClObject.ClPlatform.cruncherWillDispose">
            <summary>
            this platform is used in number crunching and will be disposed in there
            </summary>
        </member>
        <member name="M:ClObject.ClPlatform.numberOfGpus">
            <summary>
            number of gpus in this platform
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClPlatform.numberOfCpus">
            <summary>
            number of cpus in this platform
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClPlatform.numberOfAccelerators">
            <summary>
            number of accelerators in this platform
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClPlatform.h">
            <summary>
            handle to this platform in C space
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClPlatform.dispose">
            <summary>
            disposes C space platform objects
            </summary>
        </member>
        <member name="M:ClObject.ClPlatform.Finalize">
            <summary>
            release C++ resources when not needed(and not having referenced by devices)
            </summary>
        </member>
        <member name="T:ClObject.ClProgram">
            <summary>
            wrapper for cl::program
            </summary>
        </member>
        <member name="F:ClObject.ClProgram.intProgramError">
            <summary>
            error code that tells something wrong if not zero
            </summary>
        </member>
        <member name="M:ClObject.ClProgram.#ctor(ClObject.ClContext,ClObject.ClString)">
            <summary>
            creates a program from kernel string and context
            </summary>
            <param name="context"></param>
            <param name="clKernelString">kernel string to compile</param>
        </member>
        <member name="M:ClObject.ClProgram.errMsg">
            <summary>
            error message from compiler
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClProgram.h">
            <summary>
            handle to program object in "C" space
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClProgram.hc">
            <summary>
            handle to context of program (in C space)
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClProgram.hd">
            <summary>
            handle to device that was chosen to be compiled for 
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClProgram.hs">
            <summary>
            string pointer
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClProgram.dispose">
            <summary>
            release C++ resources
            </summary>
        </member>
        <member name="T:ClObject.ClString">
            <summary>
            wrapper for C++ strings 
            </summary>
        </member>
        <member name="M:ClObject.ClString.#ctor(System.String)">
            <summary>
            creates a string(C++) from a string(C#) 
            </summary>
            <param name="strg"></param>
        </member>
        <member name="M:ClObject.ClString.write(System.String)">
            <summary>
            writes to C++ string
            </summary>
            <param name="strg"></param>
        </member>
        <member name="M:ClObject.ClString.h">
            <summary>
            handle to C++ string
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClString.read">
            <summary>
            not changed in C++ side so simply returns
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.ClString.dispose">
            <summary>
            release resources in C++ side
            </summary>
        </member>
        <member name="T:ClObject.ClUserEvent">
            <summary>
            wrapper for opencl user event
            </summary>
        </member>
        <member name="M:ClObject.ClUserEvent.#ctor(ClObject.ClContext)">
            <summary>
            creates user event for fine grained synchronization
            </summary>
            <param name="ct"></param>
        </member>
        <member name="M:ClObject.ClUserEvent.dec">
            <summary>
            decrement user event counter
            </summary>
        </member>
        <member name="M:ClObject.ClUserEvent.inc">
            <summary>
            increment user event counter
            </summary>
        </member>
        <member name="M:ClObject.ClUserEvent.dispose">
            <summary>
            release C++ resources
            </summary>
        </member>
        <member name="M:ClObject.ClUserEvent.trigger">
            <summary>
            trigger user event
            </summary>
        </member>
        <member name="M:ClObject.ClUserEvent.addCommandQueue(ClObject.ClCommandQueue)">
            <summary>
            add command queue to user event
            </summary>
            <param name="cq"></param>
        </member>
        <member name="T:ClObject.Functions">
            <summary>
            helper functions
            </summary>
        </member>
        <member name="M:ClObject.Functions.isTypeOfFastArr(System.Object)">
            <summary>
            checks if object is derived from FastArr or not
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:ClObject.Functions.performanceHistoryShiftOld(System.Double[][],System.Double[])">
            <summary>
            shift each layer 1 step older, put new values to newest, oldest layer is lost
            </summary>
        </member>
        <member name="M:ClObject.Functions.performanceHistoryAverage(System.Double[][])">
            <summary>
            simple smoothing for load balance
            </summary>
            <param name="hist"></param>
            <returns></returns>
        </member>
        <member name="M:ClObject.Functions.performanceHistoryPID(System.Double[][])">
            <summary>
            quicker convergence
            </summary>
            <param name="hist"></param>
            <returns></returns>
        </member>
        <member name="M:ClObject.Functions.performanceHistoryDerivative5pStencil(System.Double[][])">
            <summary>
            finding change rate, knowing whats next before it happens
            </summary>
            <param name="hist"></param>
            <returns></returns>
        </member>
        <member name="M:ClObject.Functions.loadBalance(System.Double[],System.Boolean,System.Double[][],System.Int32,System.Int32[],System.Int32,Cekirdekler.Cores)">
            <summary>
            distribute workitems to devices accordingly with their weighted throughput
            </summary>
            <param name="benchmark">timings</param>
            <param name="smooth">smoothing on off</param>
            <param name="throughputHistory">smoothing data against OS interrupts and other effects</param>
            <param name="totalRange">global range of kernel</param>
            <param name="globalRanges">global range per device</param>
            <param name="step">minimum exchange rate of workitems between devices to balance the load</param>
        </member>
        <member name="T:ClObject.Worker">
            <summary>
            one worker per device is generated for explicit device management(but implicit for users)
            maybe more for implicit pipelining in later versions
            </summary>
        </member>
        <member name="F:ClObject.Worker.commandQueue">
            <summary>
            <para>horizontal(driver-driven) pipelining opencl queue (read + compute +write)</para>
            <para>vertical(event-driven) pipelining opencl kernel execution queue</para>
            <para>and also non-pipelined simple work</para>
            </summary>
        </member>
        <member name="F:ClObject.Worker.commandQueueRead">
            <summary>
            event-driven pipelining opencl buffer-write queue (read from C# array or C++ array)
            </summary>
        </member>
        <member name="F:ClObject.Worker.commandQueueWrite">
            <summary>
            event-driven pipelining opencl buffer-read queue (write to C# array or C++ array)
            </summary>
        </member>
        <member name="F:ClObject.Worker.commandQueue2">
            <summary>
            <para>horizontal(driver-driven) pipelining opencl queue (read + compute +write)</para>
            <para>extra vertical(event-driven) pipelining opencl kernel execution queue</para>
            </summary>
        </member>
        <member name="F:ClObject.Worker.commandQueueRead2">
            <summary>
            event-driven pipelining opencl buffer-write queue (read from C# array or C++ array)
            </summary>
        </member>
        <member name="F:ClObject.Worker.commandQueueWrite2">
            <summary>
            event-driven pipelining opencl buffer-read queue (write to C# array or C++ array)
            </summary>
        </member>
        <member name="F:ClObject.Worker.commandQueue3">
            <summary>
            extra horizontal(driver-driven) pipelining opencl queue (read + compute +write) 
            </summary>
        </member>
        <member name="F:ClObject.Worker.commandQueue4">
            <summary>
            extra horizontal(driver-driven) pipelining opencl queue (read + compute +write) 
            </summary>
        </member>
        <member name="F:ClObject.Worker.commandQueue5">
            <summary>
            extra horizontal(driver-driven) pipelining opencl queue (read + compute +write) 
            </summary>
        </member>
        <member name="F:ClObject.Worker.commandQueue6">
            <summary>
            extra horizontal(driver-driven) pipelining opencl queue (read + compute +write) 
            </summary>
        </member>
        <member name="F:ClObject.Worker.commandQueue7">
            <summary>
            extra horizontal(driver-driven) pipelining opencl queue (read + compute +write) 
            </summary>
        </member>
        <member name="F:ClObject.Worker.commandQueue8">
            <summary>
            extra horizontal(driver-driven) pipelining opencl queue (read + compute +write) 
            </summary>
        </member>
        <member name="F:ClObject.Worker.commandQueue9">
            <summary>
            extra horizontal(driver-driven) pipelining opencl queue (read + compute +write) 
            </summary>
        </member>
        <member name="F:ClObject.Worker.commandQueue10">
            <summary>
            extra horizontal(driver-driven) pipelining opencl queue (read + compute +write) 
            </summary>
        </member>
        <member name="F:ClObject.Worker.commandQueue11">
            <summary>
            extra horizontal(driver-driven) pipelining opencl queue (read + compute +write) 
            </summary>
        </member>
        <member name="F:ClObject.Worker.commandQueue12">
            <summary>
            extra horizontal(driver-driven) pipelining opencl queue (read + compute +write) 
            </summary>
        </member>
        <member name="F:ClObject.Worker.commandQueue13">
            <summary>
            extra horizontal(driver-driven) pipelining opencl queue (read + compute +write) 
            </summary>
        </member>
        <member name="F:ClObject.Worker.commandQueue14">
            <summary>
            extra horizontal(driver-driven) pipelining opencl queue (read + compute +write) 
            </summary>
        </member>
        <member name="F:ClObject.Worker.commandQueue15">
            <summary>
            extra horizontal(driver-driven) pipelining opencl queue (read + compute +write) 
            </summary>
        </member>
        <member name="F:ClObject.Worker.commandQueue16">
            <summary>
            extra horizontal(driver-driven) pipelining opencl queue (read + compute +write) 
            </summary>
        </member>
        <member name="F:ClObject.Worker.benchmark">
            <summary>
            total time
            </summary>
        </member>
        <member name="F:ClObject.Worker.deviceName">
            <summary>
            opencl device name that this worker is bound to
            </summary>
        </member>
        <member name="M:ClObject.Worker.#ctor(ClObject.ClDevice,ClObject.ClString,ClObject.ClString[],System.Boolean,System.Int32,System.Boolean)">
            <summary>
            <para>creates a worker for a device for a kernel string contains many kernel definitions and names of kernels given explicity</para>
            <para>(Cekirdekler API usage style-2 doesn't need kernel names explicitly)</para>
            </summary>
            <param name="device_">opencl device wrapper</param>
            <param name="kernels_">string wrapper containing all kernels</param>
            <param name="kernelNames_">names of kernels to be compiled on this device</param>
            <param name="computeQueueConcurrencyParameter">max queues to use</param>
            <param name="defaultQueue">OpenCL 2.0 dynamic parallelism default queue</param>
            <param name="noPipelining">if enabled, does not allocate multiple command queues(driver-driven pipelining can't be enabled). Useful for device-to-device pipelining with many stages(to overcome abundant resource usages)</param>
        </member>
        <member name="M:ClObject.Worker.kernelWithId(System.String,System.Int32)">
            <summary>
            <para> to be able to run same kernel but with different parameters and in different queues, concurrently</para>
            <para> to have multiple instances that can run same kernel with different parameters</para>
            <para> to decrease number of clSetKernelArg() calls </para>
            </summary>
            <param name="nameParameter"></param>
            <param name="idParameter">compute id to differentiate concurrent kernels with same function name</param>
            <returns></returns>
        </member>
        <member name="M:ClObject.Worker.deviceType">
            <summary>
            device type(code)
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.Worker.getAllErrors">
            <summary>
            all errors by compiler
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.Worker.getErrorCode">
            <summary>
            indicator of error
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.Worker.createUserEventForStartingPoint">
            <summary>
            experimental user event for synchronized multiple-commandqueue starter, development cancelled 
            </summary>
        </member>
        <member name="M:ClObject.Worker.bindStartPointToCommandQueues">
            <summary>
            start synchronization
            </summary>
        </member>
        <member name="M:ClObject.Worker.triggerUserEventStartPoint">
            <summary>
            trigger start action
            </summary>
        </member>
        <member name="M:ClObject.Worker.decrementUserEventCounter">
            <summary>
            decrement user event counter
            </summary>
        </member>
        <member name="M:ClObject.Worker.incrementUserEventCounter">
            <summary>
            increment user event counter
            </summary>
        </member>
        <member name="M:ClObject.Worker.deleteUserEventStartPoint">
            <summary>
            delete user event start point
            </summary>
        </member>
        <member name="M:ClObject.Worker.gddr">
            <summary>
            true: has dedicated memory
            </summary>
            <returns></returns>
        </member>
        <member name="M:ClObject.Worker.buffer(System.Object,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            prepares an opencl buffer for each C# array or other array-like object
            </summary>
            <param name="arr">float[], double[], long[], int[], byte[] gibi diziler olabilir</param>
            <param name="elementsPerThread">number of elements used in each workitem</param>
            <param name="readOnly">kernel reads, host writes</param>
            <param name="writeOnly">kernel reads, host writes</param>
            <param name="streamEnabledIfDeviceSupportsZeroCopy">Even if device is better with zero-copy, some implementations may need some arrays be non-stramed but copied</param>
        </member>
        <member name="M:ClObject.Worker.range(System.Int32)">
            <summary>
            checks if ndrange is already allocated, allocates if hasnt already
            </summary>
            <param name="num">range value</param>
            <returns></returns>
        </member>
        <member name="M:ClObject.Worker.benchmark0(System.Int32)">
            <summary>
            prepares benchmark variables for compute profiling
            </summary>
            <param name="computeId">compute id to differentiate from other compute actions</param>
        </member>
        <member name="M:ClObject.Worker.startBench">
            <summary>
            start benchmarking for load balancing
            </summary>
        </member>
        <member name="M:ClObject.Worker.endBench(System.Int32)">
            <summary>
            end benchmarking for load balancing
            </summary>
            <param name="computeId">unique id for compute action</param>
        </member>
        <member name="M:ClObject.Worker.writeToBuffer(System.Object[],System.Int32,System.Int32,System.Int32,System.String[],System.Int32[],System.Boolean,ClObject.ClCommandQueue)">
            <summary>
            read from client array and write to cl buffer (partially or all of it)
            </summary>
            <param name="arrays">kernel's parameters - arrays from C# or wrappers of C++ arrays</param>
            <param name="reference">start point of writing</param>
            <param name="range">range of writing</param>
            <param name="computeId">compute id of the writing</param>
            <param name="readWrite">"read"=read all array, "partial read"=read device share only, "write"=write partial(devie share) kernel results</param>
            <param name="elementsPerWorkItem">elements per workitem. example: streaming float4*2 means size=4</param>
            <param name="enqueueMode">if true, no synchronization</param>
            <param name="cqSelection_">only if another command queue is needed</param>
        </member>
        <member name="M:ClObject.Worker.writeToBufferWithoutPartial(System.Object[],System.String[])">
            <summary>
            non partial writes to buffer (read from array)
            </summary>
            <param name="arrs"></param>
            <param name="readWrite"></param>
        </member>
        <member name="M:ClObject.Worker.readFromBufferAllData(System.Object[],System.String[],System.Int32,System.Int32)">
            <summary>
            non partial reads from buffer (write to array)
            </summary>
            <param name="arrs"></param>
            <param name="readWrite"></param>
            <param name="deviceIndex">only one device writes an array, so multi GPU writes multi arrays alternatingly but concurrently</param>
            <param name="numDevices"></param>
        </member>
        <member name="M:ClObject.Worker.writeToBufferUsingQueueRead(System.Object[],System.Int32,System.Int32,System.Int32,System.String[],System.Int32[])">
            <summary>
            write to buffer(read from array) using queueRead queue
            </summary>
            <param name="arrs"></param>
            <param name="reference"></param>
            <param name="range"></param>
            <param name="computeId"></param>
            <param name="readWrite"></param>
            <param name="elementsPerWorkItem"></param>
        </member>
        <member name="M:ClObject.Worker.writeToBufferUsingQueueReadPartial(System.Object[],System.Int32,System.Int32,System.Int32,System.String[],System.Int32[])">
            <summary>
            write to buffer, read from array, using queueRead queue, partially
            </summary>
            <param name="arrs"></param>
            <param name="reference"></param>
            <param name="range"></param>
            <param name="computeId"></param>
            <param name="readWrite"></param>
            <param name="elementsPerWorkItem"></param>
        </member>
        <member name="M:ClObject.Worker.writeToBufferUsingQueueReadFinish">
            <summary>
            clFinish for commandqueueread
            </summary>
        </member>
        <member name="M:ClObject.Worker.writeToBufferUsingQueueReadFlush">
            <summary>
            clFlush for commandqueueread
            </summary>
        </member>
        <member name="M:ClObject.Worker.writeToBufferUsingQueueReadFinish2">
            <summary>
            clFinish for commandqueueread2
            </summary>        
        </member>
        <member name="M:ClObject.Worker.writeToBufferUsingQueueReadFlush2">
            <summary>
            clFlush for commandqueueread2
            </summary>
        </member>
        <member name="M:ClObject.Worker.kernelArgument(System.String,System.Object[],System.Int32[],System.String[],System.Int32)">
            <summary>
            binds arrays to a kernel as arguments
            </summary>
            <param name="kernelName"></param>
            <param name="arrs"></param>
            <param name="numberOfElementsOrBytes"></param>
            <param name="readWrites_"></param>
            <param name="computeId"></param>
        </member>
        <member name="M:ClObject.Worker.compute(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,ClObject.ClCommandQueue)">
            <summary>
            compute a kernel without events
            </summary>
            <param name="kernelName"></param>
            <param name="reference"></param>
            <param name="globalRange"></param>
            <param name="localRange"></param>
            <param name="computeId"></param>
            <param name="enqueueMode"></param>
            <param name="cqSelection_"></param>
        </member>
        <member name="M:ClObject.Worker.computeRepeated(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,ClObject.ClCommandQueue)">
            <summary>
            compute a kernel without events
            </summary>
            <param name="kernelName"></param>
            <param name="reference"></param>
            <param name="globalRange"></param>
            <param name="localRange"></param>
            <param name="computeId"></param>
            <param name="repeats"></param>
            <param name="enqueueMode"></param>
            <param name="cqSelection_">only if another queue is needed</param>
        </member>
        <member name="M:ClObject.Worker.computeRepeatedWithSyncKernel(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.Boolean,ClObject.ClCommandQueue)">
            <summary>
            compute a kernel without events
            </summary>
            <param name="kernelName"></param>
            <param name="reference"></param>
            <param name="globalRange"></param>
            <param name="localRange"></param>
            <param name="computeId"></param>
            <param name="repeats"></param>
            <param name="syncKernelName"></param>
            <param name="enqueueMode"></param>
            <param name="cqSelection_">only if another queue is needed</param>
        </member>
        <member name="M:ClObject.Worker.computeQueue(System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            compute with extra queue1
            </summary>
            <param name="kernelName"></param>
            <param name="reference"></param>
            <param name="globalRange"></param>
            <param name="localRange"></param>
            <param name="computeId"></param>
        </member>
        <member name="M:ClObject.Worker.computeQueueEvent(System.String,System.Int32,System.Int32,System.Int32,System.Int32,ClObject.ClEventArray,ClObject.ClEvent,System.Int32,ClObject.ClCommandQueue)">
            <summary>
            compute with extra queue2 or chosen queue
            </summary>
            <param name="kernelName"></param>
            <param name="reference"></param>
            <param name="globalRange"></param>
            <param name="localRange"></param>
            <param name="computeId"></param>
            <param name="eArr"></param>
            <param name="e"></param>
            <param name="pipelineOrder">pipeline order: 0=1st, 1=2nd pipeline</param>
            <param name="cqSelection"></param>
        </member>
        <member name="M:ClObject.Worker.computeQueueFinish">
            <summary>
            clfinish for commandqueue
            </summary>
        </member>
        <member name="M:ClObject.Worker.computeQueueFlush">
            <summary>
            clflush for commandqueue
            </summary>
        </member>
        <member name="M:ClObject.Worker.computeQueueFinish2">
            <summary>
            clfinish for commandqueue2
            </summary>
        </member>
        <member name="M:ClObject.Worker.computeQueueFlush2">
            <summary>
            clflush for commandqueue2
            </summary>
        </member>
        <member name="M:ClObject.Worker.computeQueueFinish3">
            <summary>
            clfinish for commandqueue3
            </summary>
        </member>
        <member name="M:ClObject.Worker.computeQueueFlush3">
            <summary>
            clflush for commandqueue3
            </summary>
        </member>
        <member name="M:ClObject.Worker.readFromBuffer(System.Object[],System.Int32,System.Int32,System.Int32,System.String[],System.Int32[],System.Int32,System.Int32,System.Boolean,ClObject.ClCommandQueue)">
            <summary>
             reads from buffer, writes to array
            </summary>
            <param name="arrs"></param>
            <param name="reference"></param>
            <param name="globalRange"></param>
            <param name="computeId"></param>
            <param name="readWrite"></param>
            <param name="elementsPerWorkItem"></param>
            <param name="enqueueMode"></param>
            <param name="deviceIndex">device 1 writes array 1 as a whole, device 2 writes array 2, ..., this overcomes overlapped writes on same array(undefined behavior)</param>
            <param name="cqSelection_">only if another queue is needed</param>
            <param name="numDevices">number of selected devices to distribute full array writes </param>
        </member>
        <member name="M:ClObject.Worker.readFromBufferUsingQueueWrite(System.Object[],System.Int32,System.Int32,System.Int32,System.String[],System.Int32[],System.Int32,System.Int32)">
            <summary>
            reads from buffer, writes to array, uses commandqueuewrite
            </summary>
            <param name="arrs"></param>
            <param name="reference"></param>
            <param name="globalRange"></param>
            <param name="computeId"></param>
            <param name="readWrite"></param>
            <param name="elementsPerWorkItem"></param>
            <param name="deviceIndex">device 1 writes array 1, device 2 writes array 2 when whole array needs to be written in single command, not partial, so it doesn't do undefined behaviour because of overlapped writes on same array addresses</param>
        </member>
        <member name="M:ClObject.Worker.writeToBufferUsingQueueReadPartialEvent(System.Object[],System.Int32,System.Int32,System.Int32,System.String[],System.Int32[],ClObject.ClEventArray,ClObject.ClEvent,System.Int32,ClObject.ClCommandQueue)">
            <summary>
            write to buffer using queueread with event
            </summary>
            <param name="arrs"></param>
            <param name="reference"></param>
            <param name="globalRange"></param>
            <param name="computeId"></param>
            <param name="readWrite"></param>
            <param name="elementsPerWorkItem"></param>
            <param name="eArr"></param>
            <param name="e"></param>
            <param name="pipelineOrder">0=1st pipeline, 1=2nd pipeline</param>
            <param name="cqSelection"></param>
            <returns></returns> 
        </member>
        <member name="M:ClObject.Worker.readFromBufferUsingQueueWriteEvent(System.Object[],System.Int32,System.Int32,System.Int32,System.String[],System.Int32[],ClObject.ClEventArray,ClObject.ClEvent,System.Int32,ClObject.ClCommandQueue)">
            <summary>
            read from buffer, write to array, use commandqueueWrite with events
            </summary>
            <param name="arrs"></param>
            <param name="reference"></param>
            <param name="globalRange"></param>
            <param name="computeId"></param>
            <param name="readWrite"></param>
            <param name="elementsPerWorkItem"></param>
            <param name="eArr"></param>
            <param name="e"></param>
            <param name="pipelineOrder">0:first pipeline, 1:second pipeline</param>
            <param name="cqSelection"></param>
            <returns>1=has written, 0=no write</returns>
        </member>
        <member name="M:ClObject.Worker.readBufferQueueWriteFinish">
            <summary>
            clfinish for commandqueuewrite
            </summary>
        </member>
        <member name="M:ClObject.Worker.bufferReadQueueWriteFlush">
            <summary>
            clflush for commandqueuewrite
            </summary>
        </member>
        <member name="M:ClObject.Worker.readBufferQueueWriteFinish2">
            <summary>
            clfinish for commandqueuewrite2
            </summary>
        </member>
        <member name="M:ClObject.Worker.readBufferQueueWriteFlush2">
            <summary>
            clflush for commandqueuewrite2
            </summary>
        </member>
        <member name="M:ClObject.Worker.dispose">
            <summary>
            release C++ resources
            </summary>
        </member>
        <member name="T:ClObject.JsonCPPCS">
            <summary>
            reads string from C space and converts json
            </summary>
        </member>
        <member name="M:ClObject.JsonCPPCS.jsonStringCallBack(System.IntPtr)">
            <summary>
            not a real callback actually
            </summary>
            <param name="hStringInfo"></param>
        </member>
        <member name="M:ClObject.JsonCPPCS.readWithDispose(System.IntPtr)">
            <summary>
            read string from C space string and parse by javascript serializer
            </summary>
            <param name="hStringInfo"></param>
            <returns></returns>
        </member>
        <member name="M:ClObject.JsonCPPCS.readWithoutDispose(System.IntPtr)">
            <summary>
            (without delete )read string from C space string and parse by javascript serializer
            </summary>
            <param name="hStringInfo"></param>
            <returns></returns>
        </member>
    </members>
</doc>
